import{g as getDefaultExportFromCjs,c as commonjsGlobal,a as getAugmentedNamespace}from"./index.browser.2780c866.js";import{b as buffer$1}from"./index.cc134824.js";import{c as PUBLIC_NFT_STORAGE_API_KEY,P as PUBLIC_GATEWAY_URL,a as PUBLIC_PINATA_JWT}from"./public.fa20e813.js";import{j as jwtToken,d as darktheme}from"./store.82e7b560.js";import{S as SvelteComponent,i as init,s as safe_not_equal,P as svg_element,Q as claim_svg_element,m as children,h as detach,n as attr,b as insert_hydration,G as append_hydration,H as noop$2}from"./index.a58bc7cb.js";function getIterator(t){if(typeof t.next=="function")return t;if(typeof t[Symbol.iterator]=="function")return t[Symbol.iterator]();if(typeof t[Symbol.asyncIterator]=="function")return t[Symbol.asyncIterator]();throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')}function defer(){let t,e;return{promise:new Promise((n,i)=>{e=n,t=i}),reject:t,resolve:e}}function _transform(t,e,r){const n=getIterator(r),i=[],o=[];let s=!1,a=!1,c=0,f=null;function l(){for(;o.length>0&&i.length>0;){const{resolve:u}=o.shift(),p=i.shift();u({done:!1,value:p})}for(;o.length>0&&c===0&&s;){const{resolve:u,reject:p}=o.shift();f?(p(f),f=null):u({done:!0,value:void 0})}}async function m(){if(s){l();return}if(!a&&!(c+i.length>=t)){a=!0,c++;try{const{done:u,value:p}=await n.next();u?(s=!0,c--,l()):y(p)}catch(u){s=!0,c--,f=u,l()}a=!1,m()}}async function y(u){try{const p=await e(u);i.push(p)}catch(p){s=!0,f=p}c--,l(),m()}async function h(){if(i.length===0){const p=defer();return o.push(p),m(),p.promise}const u=i.shift();return m(),{done:!1,value:u}}const d={next:h,[Symbol.asyncIterator]:()=>d};return d}function transform(t,e,r){return e===void 0?(n,i)=>i?transform(t,n,i):transform(t,n):r===void 0?n=>transform(t,e,n):_transform(t,e,r)}var pRetry$2={exports:{}},retry$2={};function RetryOperation(t,e){typeof e=="boolean"&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var retry_operation=RetryOperation;RetryOperation.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)};RetryOperation.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null};RetryOperation.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=new Date().getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.push(t),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var r=this._timeouts.shift();if(r===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),r=this._cachedTimeouts.slice(-1);else return!1;var n=this;return this._timer=setTimeout(function(){n._attempts++,n._operationTimeoutCb&&(n._timeout=setTimeout(function(){n._operationTimeoutCb(n._attempts)},n._operationTimeout),n._options.unref&&n._timeout.unref()),n._fn(n._attempts)},r),this._options.unref&&this._timer.unref(),!0};RetryOperation.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var r=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){r._operationTimeoutCb()},r._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)};RetryOperation.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)};RetryOperation.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)};RetryOperation.prototype.start=RetryOperation.prototype.try;RetryOperation.prototype.errors=function(){return this._errors};RetryOperation.prototype.attempts=function(){return this._attempts};RetryOperation.prototype.mainError=function(){if(this._errors.length===0)return null;for(var t={},e=null,r=0,n=0;n<this._errors.length;n++){var i=this._errors[n],o=i.message,s=(t[o]||0)+1;t[o]=s,s>=r&&(e=i,r=s)}return e};(function(t){var e=retry_operation;t.operation=function(r){var n=t.timeouts(r);return new e(n,{forever:r&&(r.forever||r.retries===1/0),unref:r&&r.unref,maxRetryTime:r&&r.maxRetryTime})},t.timeouts=function(r){if(r instanceof Array)return[].concat(r);var n={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var i in r)n[i]=r[i];if(n.minTimeout>n.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var o=[],s=0;s<n.retries;s++)o.push(this.createTimeout(s,n));return r&&r.forever&&!o.length&&o.push(this.createTimeout(s,n)),o.sort(function(a,c){return a-c}),o},t.createTimeout=function(r,n){var i=n.randomize?Math.random()+1:1,o=Math.round(i*Math.max(n.minTimeout,1)*Math.pow(n.factor,r));return o=Math.min(o,n.maxTimeout),o},t.wrap=function(r,n,i){if(n instanceof Array&&(i=n,n=null),!i){i=[];for(var o in r)typeof r[o]=="function"&&i.push(o)}for(var s=0;s<i.length;s++){var a=i[s],c=r[a];r[a]=(function(l){var m=t.operation(n),y=Array.prototype.slice.call(arguments,1),h=y.pop();y.push(function(d){m.retry(d)||(d&&(arguments[0]=m.mainError()),h.apply(this,arguments))}),m.attempt(function(){l.apply(r,y)})}).bind(r,c),r[a].options=n}}})(retry$2);var retry$1=retry$2;const retry=retry$1,networkErrorMsgs=["Failed to fetch","NetworkError when attempting to fetch resource.","The Internet connection appears to be offline.","Network request failed"];class AbortError extends Error{constructor(e){super(),e instanceof Error?(this.originalError=e,{message:e}=e):(this.originalError=new Error(e),this.originalError.stack=this.stack),this.name="AbortError",this.message=e}}const decorateErrorWithCounts=(t,e,r)=>{const n=r.retries-(e-1);return t.attemptNumber=e,t.retriesLeft=n,t},isNetworkError=t=>networkErrorMsgs.includes(t),pRetry=(t,e)=>new Promise((r,n)=>{e={onFailedAttempt:()=>{},retries:10,...e};const i=retry.operation(e);i.attempt(async o=>{try{r(await t(o))}catch(s){if(!(s instanceof Error)){n(new TypeError(`Non-error was thrown: "${s}". You should only throw errors.`));return}if(s instanceof AbortError)i.stop(),n(s.originalError);else if(s instanceof TypeError&&!isNetworkError(s.message))i.stop(),n(s);else{decorateErrorWithCounts(s,o,e);try{await e.onFailedAttempt(s)}catch(a){n(a);return}i.retry(s)||n(i.mainError())}}})});pRetry$2.exports=pRetry;pRetry$2.exports.default=pRetry;var AbortError_1=pRetry$2.exports.AbortError=AbortError,pRetryExports=pRetry$2.exports;const pRetry$1=getDefaultExportFromCjs(pRetryExports);var encode_1$1=encode$9,MSB$3=128,REST$3=127,MSBALL$1=~REST$3,INT$1=Math.pow(2,31);function encode$9(t,e,r){if(Number.MAX_SAFE_INTEGER&&t>Number.MAX_SAFE_INTEGER)throw encode$9.bytes=0,new RangeError("Could not encode varint");e=e||[],r=r||0;for(var n=r;t>=INT$1;)e[r++]=t&255|MSB$3,t/=128;for(;t&MSBALL$1;)e[r++]=t&255|MSB$3,t>>>=7;return e[r]=t|0,encode$9.bytes=r-n+1,e}var decode$a=read$1,MSB$2=128,REST$2=127;function read$1(t,n){var r=0,n=n||0,i=0,o=n,s,a=t.length;do{if(o>=a||i>49)throw read$1.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=i<28?(s&REST$2)<<i:(s&REST$2)*Math.pow(2,i),i+=7}while(s>=MSB$2);return read$1.bytes=o-n,r}var N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),length$1=function(t){return t<N1$1?1:t<N2$1?2:t<N3$1?3:t<N4$1?4:t<N5$1?5:t<N6$1?6:t<N7$1?7:t<N8$1?8:t<N9$1?9:10},varint$1={encode:encode_1$1,decode:decode$a,encodingLength:length$1};const varint$2=getDefaultExportFromCjs(varint$1);var encode_1=encode$8,MSB=128,REST=127,MSBALL=~REST,INT=Math.pow(2,31);function encode$8(t,e,r){e=e||[],r=r||0;for(var n=r;t>=INT;)e[r++]=t&255|MSB,t/=128;for(;t&MSBALL;)e[r++]=t&255|MSB,t>>>=7;return e[r]=t|0,encode$8.bytes=r-n+1,e}var decode$9=read,MSB$1=128,REST$1=127;function read(t,n){var r=0,n=n||0,i=0,o=n,s,a=t.length;do{if(o>=a)throw read.bytes=0,new RangeError("Could not decode varint");s=t[o++],r+=i<28?(s&REST$1)<<i:(s&REST$1)*Math.pow(2,i),i+=7}while(s>=MSB$1);return read.bytes=o-n,r}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(t){return t<N1?1:t<N2?2:t<N3?3:t<N4?4:t<N5?5:t<N6?6:t<N7?7:t<N8?8:t<N9?9:10},varint={encode:encode_1,decode:decode$9,encodingLength:length},_brrp_varint=varint;const decode$8=(t,e=0)=>[_brrp_varint.decode(t,e),_brrp_varint.decode.bytes],encodeTo=(t,e,r=0)=>(_brrp_varint.encode(t,e,r),e),encodingLength=t=>_brrp_varint.encodingLength(t),empty=new Uint8Array(0),fromHex=t=>{const e=t.match(/../g);return e?new Uint8Array(e.map(r=>parseInt(r,16))):empty},equals$1=(t,e)=>{if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;for(let r=0;r<t.byteLength;r++)if(t[r]!==e[r])return!1;return!0},coerce=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},fromString$3=t=>new TextEncoder().encode(t),toString$1=t=>new TextDecoder().decode(t),create$4=(t,e)=>{const r=e.byteLength,n=encodingLength(t),i=n+encodingLength(r),o=new Uint8Array(i+r);return encodeTo(t,o,0),encodeTo(r,o,n),o.set(e,i),new Digest(t,r,e,o)},decode$7=t=>{const e=coerce(t),[r,n]=decode$8(e),[i,o]=decode$8(e.subarray(n)),s=e.subarray(n+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new Digest(r,i,s,e)},equals=(t,e)=>t===e?!0:t.code===e.code&&t.size===e.size&&equals$1(t.bytes,e.bytes);class Digest{constructor(e,r,n,i){this.code=e,this.size=r,this.digest=n,this.bytes=i}}function base(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var i=0;i<t.length;i++){var o=t.charAt(i),s=o.charCodeAt(0);if(r[s]!==255)throw new TypeError(o+" is ambiguous");r[s]=i}var a=t.length,c=t.charAt(0),f=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function m(d){if(d instanceof Uint8Array||(ArrayBuffer.isView(d)?d=new Uint8Array(d.buffer,d.byteOffset,d.byteLength):Array.isArray(d)&&(d=Uint8Array.from(d))),!(d instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(d.length===0)return"";for(var u=0,p=0,b=0,A=d.length;b!==A&&d[b]===0;)b++,u++;for(var D=(A-b)*l+1>>>0,T=new Uint8Array(D);b!==A;){for(var g=d[b],w=0,_=D-1;(g!==0||w<p)&&_!==-1;_--,w++)g+=256*T[_]>>>0,T[_]=g%a>>>0,g=g/a>>>0;if(g!==0)throw new Error("Non-zero carry");p=w,b++}for(var $=D-p;$!==D&&T[$]===0;)$++;for(var E=c.repeat(u);$<D;++$)E+=t.charAt(T[$]);return E}function y(d){if(typeof d!="string")throw new TypeError("Expected String");if(d.length===0)return new Uint8Array;var u=0;if(d[u]!==" "){for(var p=0,b=0;d[u]===c;)p++,u++;for(var A=(d.length-u)*f+1>>>0,D=new Uint8Array(A);d[u];){var T=r[d.charCodeAt(u)];if(T===255)return;for(var g=0,w=A-1;(T!==0||g<b)&&w!==-1;w--,g++)T+=a*D[w]>>>0,D[w]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");b=g,u++}if(d[u]!==" "){for(var _=A-b;_!==A&&D[_]===0;)_++;for(var $=new Uint8Array(p+(A-_)),E=p;_!==A;)$[E++]=D[_++];return $}}}function h(d){var u=y(d);if(u)return u;throw new Error(`Non-${e} character`)}return{encode:m,decodeUnsafe:y,decode:h}}var src$2=base,_brrp__multiformats_scope_baseX=src$2;class Encoder{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Decoder{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return or(this,e)}}class ComposedDecoder{constructor(e){this.decoders=e}or(e){return or(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(t,e)=>new ComposedDecoder({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class Codec{constructor(e,r,n,i){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=i,this.encoder=new Encoder(e,r,n),this.decoder=new Decoder(e,r,i)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const from$1=({name:t,prefix:e,encode:r,decode:n})=>new Codec(t,e,r,n),baseX=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:i}=_brrp__multiformats_scope_baseX(r,e);return from$1({prefix:t,name:e,encode:n,decode:o=>coerce(i(o))})},decode$6=(t,e,r,n)=>{const i={};for(let l=0;l<e.length;++l)i[e[l]]=l;let o=t.length;for(;t[o-1]==="=";)--o;const s=new Uint8Array(o*r/8|0);let a=0,c=0,f=0;for(let l=0;l<o;++l){const m=i[t[l]];if(m===void 0)throw new SyntaxError(`Non-${n} character`);c=c<<r|m,a+=r,a>=8&&(a-=8,s[f++]=255&c>>a)}if(a>=r||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s},encode$7=(t,e,r)=>{const n=e[e.length-1]==="=",i=(1<<r)-1;let o="",s=0,a=0;for(let c=0;c<t.length;++c)for(a=a<<8|t[c],s+=8;s>r;)s-=r,o+=e[i&a>>s];if(s&&(o+=e[i&a<<r-s]),n)for(;o.length*r&7;)o+="=";return o},rfc4648=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>from$1({prefix:e,name:t,encode(i){return encode$7(i,n,r)},decode(i){return decode$6(i,n,r,t)}}),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58=Object.freeze(Object.defineProperty({__proto__:null,base58btc,base58flickr},Symbol.toStringTag,{value:"Module"})),base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$1=Object.freeze(Object.defineProperty({__proto__:null,base32,base32hex,base32hexpad,base32hexpadupper,base32hexupper,base32pad,base32padupper,base32upper,base32z},Symbol.toStringTag,{value:"Module"}));class CID{constructor(e,r,n,i){this.code=r,this.version=e,this.multihash=n,this.bytes=i,this.byteOffset=i.byteOffset,this.byteLength=i.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:hidden,byteLength:hidden,code:readonly$1,version:readonly$1,multihash:readonly$1,bytes:readonly$1,_baseCache:hidden,asCID:hidden})}toV0(){switch(this.version){case 0:return this;default:{const{code:e,multihash:r}=this;if(e!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(r.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(r)}}}toV1(){switch(this.version){case 0:{const{code:e,digest:r}=this.multihash,n=create$4(e,r);return CID.createV1(this.code,n)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&equals(this.multihash,e.multihash)}toString(e){const{bytes:r,version:n,_baseCache:i}=this;switch(n){case 0:return toStringV0(r,i,e||base58btc.encoder);default:return toStringV1(r,i,e||base32.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return deprecate(/^0\.0/,IS_CID_DEPRECATION),!!(e&&(e[cidSymbol]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof CID)return e;if(e!=null&&e.asCID===e){const{version:r,code:n,multihash:i,bytes:o}=e;return new CID(r,n,i,o||encodeCID(r,n,i.bytes))}else if(e!=null&&e[cidSymbol]===!0){const{version:r,multihash:n,code:i}=e,o=decode$7(n);return CID.create(r,i,o)}else return null}static create(e,r,n){if(typeof r!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(r!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(e,r,n,n.bytes)}case 1:{const i=encodeCID(e,r,n.bytes);return new CID(e,r,n,i)}default:throw new Error("Invalid version")}}static createV0(e){return CID.create(0,DAG_PB_CODE,e)}static createV1(e,r){return CID.create(1,e,r)}static decode(e){const[r,n]=CID.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return r}static decodeFirst(e){const r=CID.inspectBytes(e),n=r.size-r.multihashSize,i=coerce(e.subarray(n,n+r.multihashSize));if(i.byteLength!==r.multihashSize)throw new Error("Incorrect length");const o=i.subarray(r.multihashSize-r.digestSize),s=new Digest(r.multihashCode,r.digestSize,o,i);return[r.version===0?CID.createV0(s):CID.createV1(r.codec,s),e.subarray(r.size)]}static inspectBytes(e){let r=0;const n=()=>{const[m,y]=decode$8(e.subarray(r));return r+=y,m};let i=n(),o=DAG_PB_CODE;if(i===18?(i=0,r=0):i===1&&(o=n()),i!==0&&i!==1)throw new RangeError(`Invalid CID version ${i}`);const s=r,a=n(),c=n(),f=r+c,l=f-s;return{version:i,codec:o,multihashCode:a,digestSize:c,multihashSize:l,size:f}}static parse(e,r){const[n,i]=parseCIDtoBytes(e,r),o=CID.decode(i);return o._baseCache.set(n,e),o}}const parseCIDtoBytes=(t,e)=>{switch(t[0]){case"Q":{const r=e||base58btc;return[base58btc.prefix,r.decode(`${base58btc.prefix}${t}`)]}case base58btc.prefix:{const r=e||base58btc;return[base58btc.prefix,r.decode(t)]}case base32.prefix:{const r=e||base32;return[base32.prefix,r.decode(t)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[t[0],e.decode(t)]}}},toStringV0=(t,e,r)=>{const{prefix:n}=r;if(n!==base58btc.prefix)throw Error(`Cannot string encode V0 in ${r.name} encoding`);const i=e.get(n);if(i==null){const o=r.encode(t).slice(1);return e.set(n,o),o}else return i},toStringV1=(t,e,r)=>{const{prefix:n}=r,i=e.get(n);if(i==null){const o=r.encode(t);return e.set(n,o),o}else return i},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(t,e,r)=>{const n=encodingLength(t),i=n+encodingLength(e),o=new Uint8Array(i+r.byteLength);return encodeTo(t,o,0),encodeTo(e,o,n),o.set(r,i),o},cidSymbol=Symbol.for("@ipld/js-cid/CID"),readonly$1={writable:!1,configurable:!1,enumerable:!0},hidden={writable:!1,enumerable:!1,configurable:!1},version="0.0.0-dev",deprecate=(t,e)=>{if(t.test(version))console.warn(e);else throw new Error(e)},IS_CID_DEPRECATION=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(t){if(t===null)return"null";if(t===void 0)return"undefined";if(t===!0||t===!1)return"boolean";const e=typeof t;if(typeofs.includes(e))return e;if(e==="function")return"Function";if(Array.isArray(t))return"Array";if(isBuffer$1(t))return"Buffer";const r=getObjectType(t);return r||"Object"}function isBuffer$1(t){return t&&t.constructor&&t.constructor.isBuffer&&t.constructor.isBuffer.call(null,t)}function getObjectType(t){const e=Object.prototype.toString.call(t).slice(8,-1);if(objectTypeNames.includes(e))return e}class Type{constructor(e,r,n){this.major=e,this.majorEncoded=e<<5,this.name=r,this.terminal=n}toString(){return`Type[${this.major}].${this.name}`}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}Type.uint=new Type(0,"uint",!0);Type.negint=new Type(1,"negint",!0);Type.bytes=new Type(2,"bytes",!0);Type.string=new Type(3,"string",!0);Type.array=new Type(4,"array",!1);Type.map=new Type(5,"map",!1);Type.tag=new Type(6,"tag",!1);Type.float=new Type(7,"float",!0);Type.false=new Type(7,"false",!0);Type.true=new Type(7,"true",!0);Type.null=new Type(7,"null",!0);Type.undefined=new Type(7,"undefined",!0);Type.break=new Type(7,"break",!0);let Token$1=class{constructor(e,r,n){this.type=e,this.value=r,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}};const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",textDecoder$1=new TextDecoder,textEncoder$2=new TextEncoder;function isBuffer(t){return useBuffer&&globalThis.Buffer.isBuffer(t)}function asU8A(t){return t instanceof Uint8Array?isBuffer(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t:Uint8Array.from(t)}const toString=useBuffer?(t,e,r)=>r-e>64?globalThis.Buffer.from(t.subarray(e,r)).toString("utf8"):utf8Slice(t,e,r):(t,e,r)=>r-e>64?textDecoder$1.decode(t.subarray(e,r)):utf8Slice(t,e,r),fromString$2=useBuffer?t=>t.length>64?globalThis.Buffer.from(t):utf8ToBytes(t):t=>t.length>64?textEncoder$2.encode(t):utf8ToBytes(t),fromArray=t=>Uint8Array.from(t),slice=useBuffer?(t,e,r)=>isBuffer(t)?new Uint8Array(t.subarray(e,r)):t.slice(e,r):(t,e,r)=>t.slice(e,r),concat$2=useBuffer?(t,e)=>(t=t.map(r=>r instanceof Uint8Array?r:globalThis.Buffer.from(r)),asU8A(globalThis.Buffer.concat(t,e))):(t,e)=>{const r=new Uint8Array(e);let n=0;for(let i of t)n+i.length>r.length&&(i=i.subarray(0,r.length-n)),r.set(i,n),n+=i.length;return r},alloc=useBuffer?t=>globalThis.Buffer.allocUnsafe(t):t=>new Uint8Array(t);function compare(t,e){if(isBuffer(t)&&isBuffer(e))return t.compare(e);for(let r=0;r<t.length;r++)if(t[r]!==e[r])return t[r]<e[r]?-1:1;return 0}function utf8ToBytes(t,e=1/0){let r;const n=t.length;let i=null;const o=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}else if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=(i-55296<<10|r-56320)+65536}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,r&63|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,r&63|128)}else if(r<1114112){if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,r&63|128)}else throw new Error("Invalid code point")}return o}function utf8Slice(t,e,r){const n=[];for(;e<r;){const i=t[e];let o=null,s=i>239?4:i>223?3:i>191?2:1;if(e+s<=r){let a,c,f,l;switch(s){case 1:i<128&&(o=i);break;case 2:a=t[e+1],(a&192)===128&&(l=(i&31)<<6|a&63,l>127&&(o=l));break;case 3:a=t[e+1],c=t[e+2],(a&192)===128&&(c&192)===128&&(l=(i&15)<<12|(a&63)<<6|c&63,l>2047&&(l<55296||l>57343)&&(o=l));break;case 4:a=t[e+1],c=t[e+2],f=t[e+3],(a&192)===128&&(c&192)===128&&(f&192)===128&&(l=(i&15)<<18|(a&63)<<12|(c&63)<<6|f&63,l>65535&&l<1114112&&(o=l))}}o===null?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|o&1023),n.push(o),e+=s}return decodeCodePointsArray(n)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(t){const e=t.length;if(e<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,t);let r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=MAX_ARGUMENTS_LENGTH));return r}const defaultChunkSize=256;class Bl{constructor(e=defaultChunkSize){this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let r=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const i=r.length-(this.maxCursor-this.cursor)-1;r.set(e,i)}else{if(r){const i=r.length-(this.maxCursor-this.cursor)-1;i<r.length&&(this.chunks[this.chunks.length-1]=r.subarray(0,i),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(r=alloc(this.chunkSize),this.chunks.push(r),this.maxCursor+=r.length,this._initReuseChunk===null&&(this._initReuseChunk=r),r.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(e=!1){let r;if(this.chunks.length===1){const n=this.chunks[0];e&&this.cursor>n.length/2?(r=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):r=slice(n,0,this.cursor)}else r=concat$2(this.chunks,this.cursor);return e&&this.reset(),r}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(t,e,r){if(t.length-e<r)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(t,e,r){assertEnoughData(t,e,1);const n=t[e];if(r.strict===!0&&n<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint16(t,e,r){assertEnoughData(t,e,2);const n=t[e]<<8|t[e+1];if(r.strict===!0&&n<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint32(t,e,r){assertEnoughData(t,e,4);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3];if(r.strict===!0&&n<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return n}function readUint64(t,e,r){assertEnoughData(t,e,8);const n=t[e]*16777216+(t[e+1]<<16)+(t[e+2]<<8)+t[e+3],i=t[e+4]*16777216+(t[e+5]<<16)+(t[e+6]<<8)+t[e+7],o=(BigInt(n)<<BigInt(32))+BigInt(i);if(r.strict===!0&&o<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(o<=Number.MAX_SAFE_INTEGER)return Number(o);if(r.allowBigInt===!0)return o;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(t,e,r,n){return new Token$1(Type.uint,readUint8(t,e+1,n),2)}function decodeUint16(t,e,r,n){return new Token$1(Type.uint,readUint16(t,e+1,n),3)}function decodeUint32(t,e,r,n){return new Token$1(Type.uint,readUint32(t,e+1,n),5)}function decodeUint64(t,e,r,n){return new Token$1(Type.uint,readUint64(t,e+1,n),9)}function encodeUint(t,e){return encodeUintValue(t,0,e.value)}function encodeUintValue(t,e,r){if(r<uintBoundaries[0]){const n=Number(r);t.push([e|n])}else if(r<uintBoundaries[1]){const n=Number(r);t.push([e|24,n])}else if(r<uintBoundaries[2]){const n=Number(r);t.push([e|25,n>>>8,n&255])}else if(r<uintBoundaries[3]){const n=Number(r);t.push([e|26,n>>>24&255,n>>>16&255,n>>>8&255,n&255])}else{const n=BigInt(r);if(n<uintBoundaries[4]){const i=[e|27,0,0,0,0,0,0,0];let o=Number(n&BigInt(4294967295)),s=Number(n>>BigInt(32)&BigInt(4294967295));i[8]=o&255,o=o>>8,i[7]=o&255,o=o>>8,i[6]=o&255,o=o>>8,i[5]=o&255,i[4]=s&255,s=s>>8,i[3]=s&255,s=s>>8,i[2]=s&255,s=s>>8,i[1]=s&255,t.push(i)}else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)}}encodeUint.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};encodeUintValue.encodedSize=function(e){return e<uintBoundaries[0]?1:e<uintBoundaries[1]?2:e<uintBoundaries[2]?3:e<uintBoundaries[3]?5:9};encodeUint.compareTokens=function(e,r){return e.value<r.value?-1:e.value>r.value?1:0};function decodeNegint8(t,e,r,n){return new Token$1(Type.negint,-1-readUint8(t,e+1,n),2)}function decodeNegint16(t,e,r,n){return new Token$1(Type.negint,-1-readUint16(t,e+1,n),3)}function decodeNegint32(t,e,r,n){return new Token$1(Type.negint,-1-readUint32(t,e+1,n),5)}const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(t,e,r,n){const i=readUint64(t,e+1,n);if(typeof i!="bigint"){const o=-1-i;if(o>=Number.MIN_SAFE_INTEGER)return new Token$1(Type.negint,o,9)}if(n.allowBigInt!==!0)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token$1(Type.negint,neg1b-BigInt(i),9)}function encodeNegint(t,e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;encodeUintValue(t,e.type.majorEncoded,n)}encodeNegint.encodedSize=function(e){const r=e.value,n=typeof r=="bigint"?r*neg1b-pos1b:r*-1-1;return n<uintBoundaries[0]?1:n<uintBoundaries[1]?2:n<uintBoundaries[2]?3:n<uintBoundaries[3]?5:9};encodeNegint.compareTokens=function(e,r){return e.value<r.value?1:e.value>r.value?-1:0};function toToken$3(t,e,r,n){assertEnoughData(t,e,r+n);const i=slice(t,e+r,e+r+n);return new Token$1(Type.bytes,i,r+n)}function decodeBytesCompact(t,e,r,n){return toToken$3(t,e,1,r)}function decodeBytes8(t,e,r,n){return toToken$3(t,e,2,readUint8(t,e+1,n))}function decodeBytes16(t,e,r,n){return toToken$3(t,e,3,readUint16(t,e+1,n))}function decodeBytes32(t,e,r,n){return toToken$3(t,e,5,readUint32(t,e+1,n))}function decodeBytes64(t,e,r,n){const i=readUint64(t,e+1,n);if(typeof i=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(t,e,9,i)}function tokenBytes(t){return t.encodedBytes===void 0&&(t.encodedBytes=t.type===Type.string?fromString$2(t.value):t.value),t.encodedBytes}function encodeBytes(t,e){const r=tokenBytes(e);encodeUintValue(t,e.type.majorEncoded,r.length),t.push(r)}encodeBytes.encodedSize=function(e){const r=tokenBytes(e);return encodeUintValue.encodedSize(r.length)+r.length};encodeBytes.compareTokens=function(e,r){return compareBytes(tokenBytes(e),tokenBytes(r))};function compareBytes(t,e){return t.length<e.length?-1:t.length>e.length?1:compare(t,e)}function toToken$2(t,e,r,n,i){const o=r+n;assertEnoughData(t,e,o);const s=new Token$1(Type.string,toString(t,e+r,e+o),o);return i.retainStringBytes===!0&&(s.byteValue=slice(t,e+r,e+o)),s}function decodeStringCompact(t,e,r,n){return toToken$2(t,e,1,r,n)}function decodeString8(t,e,r,n){return toToken$2(t,e,2,readUint8(t,e+1,n),n)}function decodeString16(t,e,r,n){return toToken$2(t,e,3,readUint16(t,e+1,n),n)}function decodeString32(t,e,r,n){return toToken$2(t,e,5,readUint32(t,e+1,n),n)}function decodeString64(t,e,r,n){const i=readUint64(t,e+1,n);if(typeof i=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(t,e,9,i,n)}const encodeString=encodeBytes;function toToken$1(t,e,r,n){return new Token$1(Type.array,n,r)}function decodeArrayCompact(t,e,r,n){return toToken$1(t,e,1,r)}function decodeArray8(t,e,r,n){return toToken$1(t,e,2,readUint8(t,e+1,n))}function decodeArray16(t,e,r,n){return toToken$1(t,e,3,readUint16(t,e+1,n))}function decodeArray32(t,e,r,n){return toToken$1(t,e,5,readUint32(t,e+1,n))}function decodeArray64(t,e,r,n){const i=readUint64(t,e+1,n);if(typeof i=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(t,e,9,i)}function decodeArrayIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(t,e,1,1/0)}function encodeArray(t,e){encodeUintValue(t,Type.array.majorEncoded,e.value)}encodeArray.compareTokens=encodeUint.compareTokens;encodeArray.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function toToken(t,e,r,n){return new Token$1(Type.map,n,r)}function decodeMapCompact(t,e,r,n){return toToken(t,e,1,r)}function decodeMap8(t,e,r,n){return toToken(t,e,2,readUint8(t,e+1,n))}function decodeMap16(t,e,r,n){return toToken(t,e,3,readUint16(t,e+1,n))}function decodeMap32(t,e,r,n){return toToken(t,e,5,readUint32(t,e+1,n))}function decodeMap64(t,e,r,n){const i=readUint64(t,e+1,n);if(typeof i=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(t,e,9,i)}function decodeMapIndefinite(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(t,e,1,1/0)}function encodeMap(t,e){encodeUintValue(t,Type.map.majorEncoded,e.value)}encodeMap.compareTokens=encodeUint.compareTokens;encodeMap.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};function decodeTagCompact(t,e,r,n){return new Token$1(Type.tag,r,1)}function decodeTag8(t,e,r,n){return new Token$1(Type.tag,readUint8(t,e+1,n),2)}function decodeTag16(t,e,r,n){return new Token$1(Type.tag,readUint16(t,e+1,n),3)}function decodeTag32(t,e,r,n){return new Token$1(Type.tag,readUint32(t,e+1,n),5)}function decodeTag64(t,e,r,n){return new Token$1(Type.tag,readUint64(t,e+1,n),9)}function encodeTag(t,e){encodeUintValue(t,Type.tag.majorEncoded,e.value)}encodeTag.compareTokens=encodeUint.compareTokens;encodeTag.encodedSize=function(e){return encodeUintValue.encodedSize(e.value)};const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(t,e,r,n){if(n.allowUndefined===!1)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return n.coerceUndefinedToNull===!0?new Token$1(Type.null,null,1):new Token$1(Type.undefined,void 0,1)}function decodeBreak(t,e,r,n){if(n.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token$1(Type.break,void 0,1)}function createToken(t,e,r){if(r){if(r.allowNaN===!1&&Number.isNaN(t))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(r.allowInfinity===!1&&(t===1/0||t===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token$1(Type.float,t,e)}function decodeFloat16(t,e,r,n){return createToken(readFloat16(t,e+1),3,n)}function decodeFloat32(t,e,r,n){return createToken(readFloat32(t,e+1),5,n)}function decodeFloat64(t,e,r,n){return createToken(readFloat64(t,e+1),9,n)}function encodeFloat(t,e,r){const n=e.value;if(n===!1)t.push([Type.float.majorEncoded|MINOR_FALSE]);else if(n===!0)t.push([Type.float.majorEncoded|MINOR_TRUE]);else if(n===null)t.push([Type.float.majorEncoded|MINOR_NULL]);else if(n===void 0)t.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let i,o=!1;(!r||r.float64!==!0)&&(encodeFloat16(n),i=readFloat16(ui8a,1),n===i||Number.isNaN(n)?(ui8a[0]=249,t.push(ui8a.slice(0,3)),o=!0):(encodeFloat32(n),i=readFloat32(ui8a,1),n===i&&(ui8a[0]=250,t.push(ui8a.slice(0,5)),o=!0))),o||(encodeFloat64(n),i=readFloat64(ui8a,1),ui8a[0]=251,t.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function(e,r){const n=e.value;if(n===!1||n===!0||n===null||n===void 0)return 1;if(!r||r.float64!==!0){encodeFloat16(n);let i=readFloat16(ui8a,1);if(n===i||Number.isNaN(n))return 3;if(encodeFloat32(n),i=readFloat32(ui8a,1),n===i)return 5}return 9};const buffer=new ArrayBuffer(9),dataView=new DataView(buffer,1),ui8a=new Uint8Array(buffer,0);function encodeFloat16(t){if(t===1/0)dataView.setUint16(0,31744,!1);else if(t===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(t))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,t);const e=dataView.getUint32(0),r=(e&2139095040)>>23,n=e&8388607;if(r===255)dataView.setUint16(0,31744,!1);else if(r===0)dataView.setUint16(0,(t&2147483648)>>16|n>>13,!1);else{const i=r-127;i<-24?dataView.setUint16(0,0):i<-14?dataView.setUint16(0,(e&2147483648)>>16|1<<24+i,!1):dataView.setUint16(0,(e&2147483648)>>16|i+15<<10|n>>13,!1)}}}function readFloat16(t,e){if(t.length-e<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const r=(t[e]<<8)+t[e+1];if(r===31744)return 1/0;if(r===64512)return-1/0;if(r===32256)return NaN;const n=r>>10&31,i=r&1023;let o;return n===0?o=i*2**-24:n!==31?o=(i+1024)*2**(n-25):o=i===0?1/0:NaN,r&32768?-o:o}function encodeFloat32(t){dataView.setFloat32(0,t,!1)}function readFloat32(t,e){if(t.length-e<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,4).getFloat32(0,!1)}function encodeFloat64(t){dataView.setFloat64(0,t,!1)}function readFloat64(t,e){if(t.length-e<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const r=(t.byteOffset||0)+e;return new DataView(t.buffer,r,8).getFloat64(0,!1)}encodeFloat.compareTokens=encodeUint.compareTokens;function invalidMinor(t,e,r){throw new Error(`${decodeErrPrefix} encountered invalid minor (${r}) for major ${t[e]>>>5}`)}function errorer(t){return()=>{throw new Error(`${decodeErrPrefix} ${t}`)}}const jump=[];for(let t=0;t<=23;t++)jump[t]=invalidMinor;jump[24]=decodeUint8;jump[25]=decodeUint16;jump[26]=decodeUint32;jump[27]=decodeUint64;jump[28]=invalidMinor;jump[29]=invalidMinor;jump[30]=invalidMinor;jump[31]=invalidMinor;for(let t=32;t<=55;t++)jump[t]=invalidMinor;jump[56]=decodeNegint8;jump[57]=decodeNegint16;jump[58]=decodeNegint32;jump[59]=decodeNegint64;jump[60]=invalidMinor;jump[61]=invalidMinor;jump[62]=invalidMinor;jump[63]=invalidMinor;for(let t=64;t<=87;t++)jump[t]=decodeBytesCompact;jump[88]=decodeBytes8;jump[89]=decodeBytes16;jump[90]=decodeBytes32;jump[91]=decodeBytes64;jump[92]=invalidMinor;jump[93]=invalidMinor;jump[94]=invalidMinor;jump[95]=errorer("indefinite length bytes/strings are not supported");for(let t=96;t<=119;t++)jump[t]=decodeStringCompact;jump[120]=decodeString8;jump[121]=decodeString16;jump[122]=decodeString32;jump[123]=decodeString64;jump[124]=invalidMinor;jump[125]=invalidMinor;jump[126]=invalidMinor;jump[127]=errorer("indefinite length bytes/strings are not supported");for(let t=128;t<=151;t++)jump[t]=decodeArrayCompact;jump[152]=decodeArray8;jump[153]=decodeArray16;jump[154]=decodeArray32;jump[155]=decodeArray64;jump[156]=invalidMinor;jump[157]=invalidMinor;jump[158]=invalidMinor;jump[159]=decodeArrayIndefinite;for(let t=160;t<=183;t++)jump[t]=decodeMapCompact;jump[184]=decodeMap8;jump[185]=decodeMap16;jump[186]=decodeMap32;jump[187]=decodeMap64;jump[188]=invalidMinor;jump[189]=invalidMinor;jump[190]=invalidMinor;jump[191]=decodeMapIndefinite;for(let t=192;t<=215;t++)jump[t]=decodeTagCompact;jump[216]=decodeTag8;jump[217]=decodeTag16;jump[218]=decodeTag32;jump[219]=decodeTag64;jump[220]=invalidMinor;jump[221]=invalidMinor;jump[222]=invalidMinor;jump[223]=invalidMinor;for(let t=224;t<=243;t++)jump[t]=errorer("simple values are not supported");jump[244]=invalidMinor;jump[245]=invalidMinor;jump[246]=invalidMinor;jump[247]=decodeUndefined;jump[248]=errorer("simple values are not supported");jump[249]=decodeFloat16;jump[250]=decodeFloat32;jump[251]=decodeFloat64;jump[252]=invalidMinor;jump[253]=invalidMinor;jump[254]=invalidMinor;jump[255]=decodeBreak;const quick=[];for(let t=0;t<24;t++)quick[t]=new Token$1(Type.uint,t,1);for(let t=-1;t>=-24;t--)quick[31-t]=new Token$1(Type.negint,t,1);quick[64]=new Token$1(Type.bytes,new Uint8Array(0),1);quick[96]=new Token$1(Type.string,"",1);quick[128]=new Token$1(Type.array,0,1);quick[160]=new Token$1(Type.map,0,1);quick[244]=new Token$1(Type.false,!1,1);quick[245]=new Token$1(Type.true,!0,1);quick[246]=new Token$1(Type.null,null,1);function quickEncodeToken(t){switch(t.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return t.value.length?void 0:fromArray([64]);case Type.string:return t.value===""?fromArray([96]):void 0;case Type.array:return t.value===0?fromArray([128]):void 0;case Type.map:return t.value===0?fromArray([160]):void 0;case Type.uint:return t.value<24?fromArray([Number(t.value)]):void 0;case Type.negint:if(t.value>=-24)return fromArray([31-Number(t.value)])}}const defaultEncodeOptions={float64:!1,mapSorter,quickEncodeToken};function makeCborEncoders(){const t=[];return t[Type.uint.major]=encodeUint,t[Type.negint.major]=encodeNegint,t[Type.bytes.major]=encodeBytes,t[Type.string.major]=encodeString,t[Type.array.major]=encodeArray,t[Type.map.major]=encodeMap,t[Type.tag.major]=encodeTag,t[Type.float.major]=encodeFloat,t}const cborEncoders=makeCborEncoders(),buf=new Bl;class Ref{constructor(e,r){this.obj=e,this.parent=r}includes(e){let r=this;do if(r.obj===e)return!0;while(r=r.parent);return!1}static createCheck(e,r){if(e&&e.includes(r))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(r,e)}}const simpleTokens={null:new Token$1(Type.null,null),undefined:new Token$1(Type.undefined,void 0),true:new Token$1(Type.true,!0),false:new Token$1(Type.false,!1),emptyArray:new Token$1(Type.array,0),emptyMap:new Token$1(Type.map,0)},typeEncoders={number(t,e,r,n){return!Number.isInteger(t)||!Number.isSafeInteger(t)?new Token$1(Type.float,t):t>=0?new Token$1(Type.uint,t):new Token$1(Type.negint,t)},bigint(t,e,r,n){return t>=BigInt(0)?new Token$1(Type.uint,t):new Token$1(Type.negint,t)},Uint8Array(t,e,r,n){return new Token$1(Type.bytes,t)},string(t,e,r,n){return new Token$1(Type.string,t)},boolean(t,e,r,n){return t?simpleTokens.true:simpleTokens.false},null(t,e,r,n){return simpleTokens.null},undefined(t,e,r,n){return simpleTokens.undefined},ArrayBuffer(t,e,r,n){return new Token$1(Type.bytes,new Uint8Array(t))},DataView(t,e,r,n){return new Token$1(Type.bytes,new Uint8Array(t.buffer,t.byteOffset,t.byteLength))},Array(t,e,r,n){if(!t.length)return r.addBreakTokens===!0?[simpleTokens.emptyArray,new Token$1(Type.break)]:simpleTokens.emptyArray;n=Ref.createCheck(n,t);const i=[];let o=0;for(const s of t)i[o++]=objectToTokens(s,r,n);return r.addBreakTokens?[new Token$1(Type.array,t.length),i,new Token$1(Type.break)]:[new Token$1(Type.array,t.length),i]},Object(t,e,r,n){const i=e!=="Object",o=i?t.keys():Object.keys(t),s=i?t.size:o.length;if(!s)return r.addBreakTokens===!0?[simpleTokens.emptyMap,new Token$1(Type.break)]:simpleTokens.emptyMap;n=Ref.createCheck(n,t);const a=[];let c=0;for(const f of o)a[c++]=[objectToTokens(f,r,n),objectToTokens(i?t.get(f):t[f],r,n)];return sortMapEntries(a,r),r.addBreakTokens?[new Token$1(Type.map,s),a,new Token$1(Type.break)]:[new Token$1(Type.map,s),a]}};typeEncoders.Map=typeEncoders.Object;typeEncoders.Buffer=typeEncoders.Uint8Array;for(const t of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${t}Array`]=typeEncoders.DataView;function objectToTokens(t,e={},r){const n=is(t),i=e&&e.typeEncoders&&e.typeEncoders[n]||typeEncoders[n];if(typeof i=="function"){const s=i(t,n,e,r);if(s!=null)return s}const o=typeEncoders[n];if(!o)throw new Error(`${encodeErrPrefix} unsupported type: ${n}`);return o(t,n,e,r)}function sortMapEntries(t,e){e.mapSorter&&t.sort(e.mapSorter)}function mapSorter(t,e){const r=Array.isArray(t[0])?t[0][0]:t[0],n=Array.isArray(e[0])?e[0][0]:e[0];if(r.type!==n.type)return r.type.compare(n.type);const i=r.type.major,o=cborEncoders[i].compareTokens(r,n);return o===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),o}function tokensToEncoded(t,e,r,n){if(Array.isArray(e))for(const i of e)tokensToEncoded(t,i,r,n);else r[e.type.major](t,e,n)}function encodeCustom(t,e,r){const n=objectToTokens(t,r);if(!Array.isArray(n)&&r.quickEncodeToken){const i=r.quickEncodeToken(n);if(i)return i;const o=e[n.type.major];if(o.encodedSize){const s=o.encodedSize(n,r),a=new Bl(s);if(o(a,n,r),a.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);return asU8A(a.chunks[0])}}return buf.reset(),tokensToEncoded(buf,n,e,r),buf.toBytes(!0)}function encode$6(t,e){return e=Object.assign({},defaultEncodeOptions,e),encodeCustom(t,cborEncoders,e)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(e,r={}){this.pos=0,this.data=e,this.options=r}done(){return this.pos>=this.data.length}next(){const e=this.data[this.pos];let r=quick[e];if(r===void 0){const n=jump[e];if(!n)throw new Error(`${decodeErrPrefix} no decoder for major type ${e>>>5} (byte 0x${e.toString(16).padStart(2,"0")})`);const i=e&31;r=n(this.data,this.pos,i,this.options)}return this.pos+=r.encodedLength,r}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(t,e,r){const n=[];for(let i=0;i<t.value;i++){const o=tokensToObject(e,r);if(o===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(o===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${t.value})`);n[i]=o}return n}function tokenToMap(t,e,r){const n=r.useMaps===!0,i=n?void 0:{},o=n?new Map:void 0;for(let s=0;s<t.value;s++){const a=tokensToObject(e,r);if(a===BREAK){if(t.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(a===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no key], expected ${t.value})`);if(n!==!0&&typeof a!="string")throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof a})`);if(r.rejectDuplicateMapKeys===!0&&(n&&o.has(a)||!n&&a in i))throw new Error(`${decodeErrPrefix} found repeat map key "${a}"`);const c=tokensToObject(e,r);if(c===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${s} [no value], expected ${t.value})`);n?o.set(a,c):i[a]=c}return n?o:i}function tokensToObject(t,e){if(t.done())return DONE;const r=t.next();if(r.type===Type.break)return BREAK;if(r.type.terminal)return r.value;if(r.type===Type.array)return tokenToArray(r,t,e);if(r.type===Type.map)return tokenToMap(r,t,e);if(r.type===Type.tag){if(e.tags&&typeof e.tags[r.value]=="function"){const n=tokensToObject(t,e);return e.tags[r.value](n)}throw new Error(`${decodeErrPrefix} tag not supported (${r.value})`)}throw new Error("unsupported")}function decode$5(t,e){if(!(t instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);e=Object.assign({},defaultDecodeOptions,e);const r=e.tokenizer||new Tokeniser(t,e),n=tokensToObject(r,e);if(n===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(n===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);if(!r.done())throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return n}const CID_CBOR_TAG$1=42;function cidEncoder$1(t){if(t.asCID!==t)return null;const e=CID.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token$1(Type.tag,CID_CBOR_TAG$1),new Token$1(Type.bytes,r)]}function undefinedEncoder$1(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder$1(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions$1={float64:!0,typeEncoders:{Object:cidEncoder$1,undefined:undefinedEncoder$1,number:numberEncoder$1}};function cidDecoder$1(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(t.subarray(1))}const decodeOptions$1={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions$1.tags[CID_CBOR_TAG$1]=cidDecoder$1;const encode$5=t=>encode$6(t,encodeOptions$1),decode$4=t=>decode$5(t,decodeOptions$1),CIDV0_BYTES={SHA2_256:18,LENGTH:32,DAG_PB:112};async function readVarint(t){const e=await t.upTo(8),r=varint$2.decode(e);return t.seek(varint$2.decode.bytes),r}async function readHeader(t){const e=await readVarint(t);if(e===0)throw new Error("Invalid CAR header (zero length)");const r=await t.exactly(e);t.seek(e);const n=decode$4(r);if(n==null||Array.isArray(n)||typeof n!="object")throw new Error("Invalid CAR header format");if(n.version!==1)throw typeof n.version=="string"?new Error(`Invalid CAR version: "${n.version}"`):new Error(`Invalid CAR version: ${n.version}`);if(!Array.isArray(n.roots))throw new Error("Invalid CAR header format");if(Object.keys(n).filter(i=>i!=="roots"&&i!=="version").length)throw new Error("Invalid CAR header format");return n}async function readMultihash(t){const e=await t.upTo(8);varint$2.decode(e);const r=varint$2.decode.bytes,n=varint$2.decode(e.subarray(varint$2.decode.bytes)),i=varint$2.decode.bytes,o=r+i+n,s=await t.exactly(o);return t.seek(o),s}async function readCid(t){const e=await t.exactly(2);if(e[0]===CIDV0_BYTES.SHA2_256&&e[1]===CIDV0_BYTES.LENGTH){const s=await t.exactly(34);t.seek(34);const a=decode$7(s);return CID.create(0,CIDV0_BYTES.DAG_PB,a)}const r=await readVarint(t);if(r!==1)throw new Error(`Unexpected CID version (${r})`);const n=await readVarint(t),i=await readMultihash(t),o=decode$7(i);return CID.create(r,n,o)}async function readBlockHead(t){const e=t.pos;let r=await readVarint(t);if(r===0)throw new Error("Invalid CAR section (zero length)");r+=t.pos-e;const n=await readCid(t),i=r-(t.pos-e);return{cid:n,length:r,blockLength:i}}async function readBlock(t){const{cid:e,blockLength:r}=await readBlockHead(t),n=await t.exactly(r);return t.seek(r),{bytes:n,cid:e}}async function readBlockIndex(t){const e=t.pos,{cid:r,length:n,blockLength:i}=await readBlockHead(t),o={cid:r,length:n,blockLength:i,offset:e,blockOffset:t.pos};return t.seek(o.blockLength),o}function createDecoder(t){const e=readHeader(t);return{header:()=>e,async*blocks(){for(await e;(await t.upTo(8)).length>0;)yield await readBlock(t)},async*blocksIndex(){for(await e;(await t.upTo(8)).length>0;)yield await readBlockIndex(t)}}}function bytesReader(t){let e=0;return{async upTo(r){return t.subarray(e,e+Math.min(r,t.length-e))},async exactly(r){if(r>t.length-e)throw new Error("Unexpected end of data");return t.subarray(e,e+r)},seek(r){e+=r},get pos(){return e}}}function chunkReader(t){let e=0,r=0,n=0,i=new Uint8Array(0);const o=async s=>{r=i.length-n;const a=[i.subarray(n)];for(;r<s;){const f=await t();if(f==null)break;r<0?f.length>r&&a.push(f.subarray(-r)):a.push(f),r+=f.length}i=new Uint8Array(a.reduce((f,l)=>f+l.length,0));let c=0;for(const f of a)i.set(f,c),c+=f.length;n=0};return{async upTo(s){return i.length-n<s&&await o(s),i.subarray(n,n+Math.min(i.length-n,s))},async exactly(s){if(i.length-n<s&&await o(s),i.length-n<s)throw new Error("Unexpected end of data");return i.subarray(n,n+s)},seek(s){e+=s,n+=s},get pos(){return e}}}function asyncIterableReader(t){const e=t[Symbol.asyncIterator]();async function r(){const n=await e.next();return n.done?null:n.value}return chunkReader(r)}class CarReader{constructor(e,r,n){this._version=e,this._roots=r,this._blocks=n,this._keys=n.map(i=>i.cid.toString())}get version(){return this._version}async getRoots(){return this._roots}async has(e){return this._keys.indexOf(e.toString())>-1}async get(e){const r=this._keys.indexOf(e.toString());return r>-1?this._blocks[r]:void 0}async*blocks(){for(const e of this._blocks)yield e}async*cids(){for(const e of this._blocks)yield e.cid}static async fromBytes(e){if(!(e instanceof Uint8Array))throw new TypeError("fromBytes() requires a Uint8Array");return decodeReaderComplete(bytesReader(e))}static async fromIterable(e){if(!e||typeof e[Symbol.asyncIterator]!="function")throw new TypeError("fromIterable() requires an async iterable");return decodeReaderComplete(asyncIterableReader(e))}}async function decodeReaderComplete(t){const e=createDecoder(t),{version:r,roots:n}=await e.header(),i=[];for await(const o of e.blocks())i.push(o);return new CarReader(r,n,i)}function createHeader(t){const e=encode$5({version:1,roots:t}),r=varint$2.encode(e.length),n=new Uint8Array(r.length+e.length);return n.set(r,0),n.set(e,r.length),n}function createEncoder(t){return{async setRoots(e){const r=createHeader(e);await t.write(r)},async writeBlock(e){const{cid:r,bytes:n}=e;await t.write(new Uint8Array(varint$2.encode(r.bytes.length+n.length))),await t.write(r.bytes),n.length&&await t.write(n)},async close(){return t.end()}}}function noop$1(){}function create$3(){const t=[];let e=null,r=noop$1,n=!1,i=null,o=noop$1;const s=()=>(e||(e=new Promise(f=>{r=()=>{e=null,r=noop$1,f()}})),e),a={write(f){t.push(f);const l=s();return o(),l},async end(){n=!0;const f=s();return o(),f}},c={async next(){const f=t.shift();return f?(t.length===0&&r(),{done:!1,value:f}):n?(r(),{done:!0,value:void 0}):(i||(i=new Promise(l=>{o=()=>(i=null,o=noop$1,l(c.next()))})),i)}};return{writer:a,iterator:c}}class CarWriter{constructor(e,r){this._encoder=r,this._mutex=r.setRoots(e),this._ended=!1}async put(e){if(!(e.bytes instanceof Uint8Array)||!e.cid)throw new TypeError("Can only write {cid, bytes} objects");if(this._ended)throw new Error("Already closed");const r=CID.asCID(e.cid);if(!r)throw new TypeError("Can only write {cid, bytes} objects");return this._mutex=this._mutex.then(()=>this._encoder.writeBlock({cid:r,bytes:e.bytes})),this._mutex}async close(){if(this._ended)throw new Error("Already closed");return await this._mutex,this._ended=!0,this._encoder.close()}static create(e){e=toRoots(e);const{encoder:r,iterator:n}=encodeWriter(),i=new CarWriter(e,r),o=new CarWriterOut(n);return{writer:i,out:o}}static createAppender(){const{encoder:e,iterator:r}=encodeWriter();e.setRoots=()=>Promise.resolve();const n=new CarWriter([],e),i=new CarWriterOut(r);return{writer:n,out:i}}static async updateRootsInBytes(e,r){const n=bytesReader(e);await readHeader(n);const i=createHeader(r);if(n.pos!==i.length)throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${n.pos} bytes, new header is ${i.length} bytes)`);return e.set(i,0),e}}class CarWriterOut{constructor(e){this._iterator=e}[Symbol.asyncIterator](){if(this._iterating)throw new Error("Multiple iterator not supported");return this._iterating=!0,this._iterator}}function encodeWriter(){const t=create$3(),{writer:e,iterator:r}=t;return{encoder:createEncoder(e),iterator:r}}function toRoots(t){if(t===void 0)return[];if(!Array.isArray(t)){const r=CID.asCID(t);if(!r)throw new TypeError("roots must be a single CID or an array of CIDs");return[r]}const e=[];for(const r of t){const n=CID.asCID(r);if(!n)throw new TypeError("roots must be a single CID or an array of CIDs");e.push(n)}return e}const from=({name:t,code:e,encode:r})=>new Hasher(t,e,r);class Hasher{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?create$4(this.code,r):r.then(n=>create$4(this.code,n))}else throw Error("Unknown type, must be binary type")}}const readonly=({enumerable:t=!0,configurable:e=!1}={})=>({enumerable:t,configurable:e,writable:!1}),links=function*(t,e){if(t!=null&&!(t instanceof Uint8Array))for(const[r,n]of Object.entries(t)){const i=[...e,r];if(n!=null&&typeof n=="object")if(Array.isArray(n))for(const[o,s]of n.entries()){const a=[...i,o],c=CID.asCID(s);c?yield[a.join("/"),c]:typeof s=="object"&&(yield*links(s,a))}else{const o=CID.asCID(n);o?yield[i.join("/"),o]:yield*links(n,i)}}},tree=function*(t,e){if(t!=null)for(const[r,n]of Object.entries(t)){const i=[...e,r];if(yield i.join("/"),n!=null&&!(n instanceof Uint8Array)&&typeof n=="object"&&!CID.asCID(n))if(Array.isArray(n))for(const[o,s]of n.entries()){const a=[...i,o];yield a.join("/"),typeof s=="object"&&!CID.asCID(s)&&(yield*tree(s,a))}else yield*tree(n,i)}},get=(t,e)=>{let r=t;for(const[n,i]of e.entries()){if(r=r[i],r==null)throw new Error(`Object has no property at ${e.slice(0,n+1).map(s=>`[${JSON.stringify(s)}]`).join("")}`);const o=CID.asCID(r);if(o)return{value:o,remaining:e.slice(n+1).join("/")}}return{value:r}};class Block{constructor({cid:e,bytes:r,value:n}){if(!e||!r||typeof n>"u")throw new Error("Missing required argument");this.cid=e,this.bytes=r,this.value=n,this.asBlock=this,Object.defineProperties(this,{cid:readonly(),bytes:readonly(),value:readonly(),asBlock:readonly()})}links(){return links(this.value,[])}tree(){return tree(this.value,[])}get(e="/"){return get(this.value,e.split("/").filter(Boolean))}}const encode$4=async({value:t,codec:e,hasher:r})=>{if(typeof t>"u")throw new Error('Missing required argument "value"');if(!e||!r)throw new Error("Missing required argument: codec or hasher");const n=e.encode(t),i=await r.digest(n),o=CID.create(1,e.code,i);return new Block({value:t,bytes:n,cid:o})},name$2="raw",code$2=85,encode$3=t=>coerce(t),decode$3=t=>coerce(t),raw=Object.freeze(Object.defineProperty({__proto__:null,code:code$2,decode:decode$3,encode:encode$3,name:name$2},Symbol.toStringTag,{value:"Module"})),CID_CBOR_TAG=42;function cidEncoder(t){if(t.asCID!==t)return null;const e=CID.asCID(t);if(!e)return null;const r=new Uint8Array(e.bytes.byteLength+1);return r.set(e.bytes,1),[new Token$1(Type.tag,CID_CBOR_TAG),new Token$1(Type.bytes,r)]}function undefinedEncoder(){throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded")}function numberEncoder(t){if(Number.isNaN(t))throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");if(t===1/0||t===-1/0)throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");return null}const encodeOptions={float64:!0,typeEncoders:{Object:cidEncoder,undefined:undefinedEncoder,number:numberEncoder}};function cidDecoder(t){if(t[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(t.subarray(1))}const decodeOptions={allowIndefinite:!1,allowUndefined:!1,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,tags:[]};decodeOptions.tags[CID_CBOR_TAG]=cidDecoder;const name$1="dag-cbor",code$1=113,encode$2=t=>encode$6(t,encodeOptions),decode$2=t=>decode$5(t,decodeOptions),dagCbor=Object.freeze(Object.defineProperty({__proto__:null,code:code$1,decode:decode$2,encode:encode$2,name:name$1},Symbol.toStringTag,{value:"Module"})),textDecoder=new TextDecoder;function decodeVarint(t,e){let r=0;for(let n=0;;n+=7){if(n>=64)throw new Error("protobuf: varint overflow");if(e>=t.length)throw new Error("protobuf: unexpected end of data");const i=t[e++];if(r+=n<28?(i&127)<<n:(i&127)*2**n,i<128)break}return[r,e]}function decodeBytes(t,e){let r;[r,e]=decodeVarint(t,e);const n=e+r;if(r<0||n<0)throw new Error("protobuf: invalid length");if(n>t.length)throw new Error("protobuf: unexpected end of data");return[t.subarray(e,n),n]}function decodeKey(t,e){let r;return[r,e]=decodeVarint(t,e),[r&7,r>>3,e]}function decodeLink(t){const e={},r=t.length;let n=0;for(;n<r;){let i,o;if([i,o,n]=decodeKey(t,n),o===1){if(e.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(i!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${i}) for Hash`);if(e.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[e.Hash,n]=decodeBytes(t,n)}else if(o===2){if(e.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(i!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${i}) for Name`);if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let s;[s,n]=decodeBytes(t,n),e.Name=textDecoder.decode(s)}else if(o===3){if(e.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(i!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${i}) for Tsize`);[e.Tsize,n]=decodeVarint(t,n)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`)}if(n>r)throw new Error("protobuf: (PBLink) unexpected end of data");return e}function decodeNode(t){const e=t.length;let r=0,n,i=!1,o;for(;r<e;){let a,c;if([a,c,r]=decodeKey(t,r),a!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${a}`);if(c===1){if(o)throw new Error("protobuf: (PBNode) duplicate Data section");[o,r]=decodeBytes(t,r),n&&(i=!0)}else if(c===2){if(i)throw new Error("protobuf: (PBNode) duplicate Links section");n||(n=[]);let f;[f,r]=decodeBytes(t,r),n.push(decodeLink(f))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${c}`)}if(r>e)throw new Error("protobuf: (PBNode) unexpected end of data");const s={};return o&&(s.Data=o),s.Links=n||[],s}const textEncoder$1=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink(t,e){let r=e.length;if(typeof t.Tsize=="number"){if(t.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(t.Tsize))throw new Error("Tsize too large for encoding");r=encodeVarint(e,r,t.Tsize)-1,e[r]=24}if(typeof t.Name=="string"){const n=textEncoder$1.encode(t.Name);r-=n.length,e.set(n,r),r=encodeVarint(e,r,n.length)-1,e[r]=18}return t.Hash&&(r-=t.Hash.length,e.set(t.Hash,r),r=encodeVarint(e,r,t.Hash.length)-1,e[r]=10),e.length-r}function encodeNode(t){const e=sizeNode(t),r=new Uint8Array(e);let n=e;if(t.Data&&(n-=t.Data.length,r.set(t.Data,n),n=encodeVarint(r,n,t.Data.length)-1,r[n]=10),t.Links)for(let i=t.Links.length-1;i>=0;i--){const o=encodeLink(t.Links[i],r.subarray(0,n));n-=o,n=encodeVarint(r,n,o)-1,r[n]=18}return r}function sizeLink(t){let e=0;if(t.Hash){const r=t.Hash.length;e+=1+r+sov(r)}if(typeof t.Name=="string"){const r=textEncoder$1.encode(t.Name).length;e+=1+r+sov(r)}return typeof t.Tsize=="number"&&(e+=1+sov(t.Tsize)),e}function sizeNode(t){let e=0;if(t.Data){const r=t.Data.length;e+=1+r+sov(r)}if(t.Links)for(const r of t.Links){const n=sizeLink(r);e+=1+n+sov(n)}return e}function encodeVarint(t,e,r){e-=sov(r);const n=e;for(;r>=maxUInt32;)t[e++]=r&127|128,r/=128;for(;r>=128;)t[e++]=r&127|128,r>>>=7;return t[e]=r,n}function sov(t){return t%2===0&&t++,Math.floor((len64(t)+6)/7)}function len64(t){let e=0;return t>=maxInt32&&(t=Math.floor(t/maxInt32),e=32),t>=65536&&(t>>>=16,e+=16),t>=256&&(t>>>=8,e+=8),e+len8tab[t]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder=new TextEncoder;function linkComparator(t,e){if(t===e)return 0;const r=t.Name?textEncoder.encode(t.Name):[],n=e.Name?textEncoder.encode(e.Name):[];let i=r.length,o=n.length;for(let s=0,a=Math.min(i,o);s<a;++s)if(r[s]!==n[s]){i=r[s],o=n[s];break}return i<o?-1:o<i?1:0}function hasOnlyProperties(t,e){return!Object.keys(t).some(r=>!e.includes(r))}function asLink(t){if(typeof t.asCID=="object"){const r=CID.asCID(t);if(!r)throw new TypeError("Invalid DAG-PB form");return{Hash:r}}if(typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Hash){let r=CID.asCID(t.Hash);try{r||(typeof t.Hash=="string"?r=CID.parse(t.Hash):t.Hash instanceof Uint8Array&&(r=CID.decode(t.Hash)))}catch(n){throw new TypeError(`Invalid DAG-PB form: ${n.message}`)}r&&(e.Hash=r)}if(!e.Hash)throw new TypeError("Invalid DAG-PB form");return typeof t.Name=="string"&&(e.Name=t.Name),typeof t.Tsize=="number"&&(e.Tsize=t.Tsize),e}function prepare(t){if((t instanceof Uint8Array||typeof t=="string")&&(t={Data:t}),typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");const e={};if(t.Data!==void 0)if(typeof t.Data=="string")e.Data=textEncoder.encode(t.Data);else if(t.Data instanceof Uint8Array)e.Data=t.Data;else throw new TypeError("Invalid DAG-PB form");if(t.Links!==void 0)if(Array.isArray(t.Links))e.Links=t.Links.map(asLink),e.Links.sort(linkComparator);else throw new TypeError("Invalid DAG-PB form");else e.Links=[];return e}function validate(t){if(!t||typeof t!="object"||Array.isArray(t))throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(t,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(t.Data!==void 0&&!(t.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");if(!Array.isArray(t.Links))throw new TypeError("Invalid DAG-PB form (Links must be an array)");for(let e=0;e<t.Links.length;e++){const r=t.Links[e];if(!r||typeof r!="object"||Array.isArray(r))throw new TypeError("Invalid DAG-PB form (bad link object)");if(!hasOnlyProperties(r,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");if(!r.Hash)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(r.Hash.asCID!==r.Hash)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(r.Name!==void 0&&typeof r.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(r.Tsize!==void 0&&(typeof r.Tsize!="number"||r.Tsize%1!==0))throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(e>0&&linkComparator(r,t.Links[e-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function createNode(t,e=[]){return prepare({Data:t,Links:e})}function createLink(t,e,r){return asLink({Hash:r,Name:t,Tsize:e})}const name="dag-pb",code=112;function encode$1(t){validate(t);const e={};return t.Links&&(e.Links=t.Links.map(r=>{const n={};return r.Hash&&(n.Hash=r.Hash.bytes),r.Name!==void 0&&(n.Name=r.Name),r.Tsize!==void 0&&(n.Tsize=r.Tsize),n})),t.Data&&(e.Data=t.Data),encodeNode(e)}function decode$1(t){const e=decodeNode(t),r={};return e.Data&&(r.Data=e.Data),e.Links&&(r.Links=e.Links.map(n=>{const i={};try{i.Hash=CID.decode(n.Hash)}catch{}if(!i.Hash)throw new Error("Invalid Hash field found in link, expected CID");return n.Name!==void 0&&(i.Name=n.Name),n.Tsize!==void 0&&(i.Tsize=n.Tsize),i})),r}const dagPb=Object.freeze(Object.defineProperty({__proto__:null,code,createLink,createNode,decode:decode$1,encode:encode$1,name,prepare,validate},Symbol.toStringTag,{value:"Module"}));class TreewalkCarSplitter{constructor(e,r,n={}){if(typeof r!="number"||r<=0)throw new Error("invalid target chunk size");this._reader=e,this._targetSize=r,this._decoders=[dagPb,raw,dagCbor,...n.decoders||[]]}async*cars(){const e=await this._reader.getRoots();if(e.length!==1)throw new Error(`unexpected number of roots: ${e.length}`);let r;for await(const n of this._cars(e[0]))r=n.channel,n.out&&(yield n.out);if(!r)throw new Error("missing CAR writer channel");r.writer.close(),yield r.out}async _get(e){const r=await this._reader.get(e);if(!r)throw new Error(`missing block for ${e}`);const{bytes:n}=r,i=this._decoders.find(o=>o.code===e.code);if(!i)throw new Error(`missing decoder for ${e.code}`);return new Block({cid:e,bytes:n,value:i.decode(n)})}async*_cars(e,r=[],n=void 0){const i=await this._get(e);if(n=n||Object.assign(CarWriter.create(e),{size:0}),n.size>0&&n.size+i.bytes.byteLength>=this._targetSize){n.writer.close();const{out:o}=n;n=newCar(r),yield{channel:n,out:o}}r=r.concat(i),n.size+=i.bytes.byteLength,n.writer.put(i);for(const[,o]of i.links())for await(const s of this._cars(o,r,n))n=s.channel,yield s;if(!n)throw new Error("missing CAR writer channel");yield{channel:n}}static async fromIterable(e,r,n){const i=await CarReader.fromIterable(e);return new TreewalkCarSplitter(i,r,n)}static async fromBlob(e,r,n){const i=await e.arrayBuffer(),o=await CarReader.fromBytes(new Uint8Array(i));return new TreewalkCarSplitter(o,r,n)}}function newCar(t){const e=Object.assign(CarWriter.create(t[0].cid),{size:t.reduce((r,n)=>r+n.bytes.byteLength,0)});for(const r of t)e.writer.put(r);return e}const last=async t=>{let e;for await(const r of t)e=r;return e};var itLast=last;const last$1=getDefaultExportFromCjs(itLast);var itPipe={exports:{}};const rawPipe=(...t)=>{let e;for(;t.length;)e=t.shift()(e);return e},isIterable$1=t=>t&&(typeof t[Symbol.asyncIterator]=="function"||typeof t[Symbol.iterator]=="function"||typeof t.next=="function"),isDuplex=t=>t&&typeof t.sink=="function"&&isIterable$1(t.source),duplexPipelineFn=t=>e=>(t.sink(e),t.source),pipe=(...t)=>{if(isDuplex(t[0])){const e=t[0];t[0]=()=>e.source}else if(isIterable$1(t[0])){const e=t[0];t[0]=()=>e}if(t.length>1&&isDuplex(t[t.length-1])&&(t[t.length-1]=t[t.length-1].sink),t.length>2)for(let e=1;e<t.length-1;e++)isDuplex(t[e])&&(t[e]=duplexPipelineFn(t[e]));return rawPipe(...t)};itPipe.exports=pipe;itPipe.exports.pipe=pipe;itPipe.exports.rawPipe=rawPipe;itPipe.exports.isIterable=isIterable$1;itPipe.exports.isDuplex=isDuplex;var itPipeExports=itPipe.exports;const pipe$1=getDefaultExportFromCjs(itPipeExports);async function*batch$1(t,e=1){let r=[];e<1&&(e=1);for await(const n of t)for(r.push(n);r.length>=e;)yield r.slice(0,e),r=r.slice(e);for(;r.length;)yield r.slice(0,e),r=r.slice(e)}var itBatch=batch$1;const batch$2=getDefaultExportFromCjs(itBatch),batch=itBatch;async function*parallelBatch(t,e=1){for await(const r of batch(t,e)){const n=r.map(i=>i().then(o=>({ok:!0,value:o}),o=>({ok:!1,err:o})));for(let i=0;i<n.length;i++){const o=await n[i];if(o.ok)yield o.value;else throw o.err}}}var itParallelBatch=parallelBatch;const parallelBatch$1=getDefaultExportFromCjs(itParallelBatch);var isPlainObj=t=>{if(Object.prototype.toString.call(t)!=="[object Object]")return!1;const e=Object.getPrototypeOf(t);return e===null||e===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(t,e,r)=>Object.defineProperty(t,e,{value:r,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=t=>{const e=[];for(const r in t)hasOwnProperty.call(t,r)&&e.push(r);if(Object.getOwnPropertySymbols){const r=Object.getOwnPropertySymbols(t);for(const n of r)propertyIsEnumerable.call(t,n)&&e.push(n)}return e};function clone(t){return Array.isArray(t)?cloneArray(t):isOptionObject(t)?cloneOptionObject(t):t}function cloneArray(t){const e=t.slice(0,0);return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}function cloneOptionObject(t){const e=Object.getPrototypeOf(t)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(t).forEach(r=>{defineProperty(e,r,clone(t[r]))}),e}const mergeKeys=(t,e,r,n)=>(r.forEach(i=>{typeof e[i]>"u"&&n.ignoreUndefined||(i in t&&t[i]!==Object.getPrototypeOf(t)?defineProperty(t,i,merge(t[i],e[i],n)):defineProperty(t,i,clone(e[i])))}),t),concatArrays=(t,e,r)=>{let n=t.slice(0,0),i=0;return[t,e].forEach(o=>{const s=[];for(let a=0;a<o.length;a++)hasOwnProperty.call(o,a)&&(s.push(String(a)),o===t?defineProperty(n,i++,o[a]):defineProperty(n,i++,clone(o[a])));n=mergeKeys(n,o,getEnumerableOwnPropertyKeys(o).filter(a=>!s.includes(a)),r)}),n};function merge(t,e,r){return r.concatArrays&&Array.isArray(t)&&Array.isArray(e)?concatArrays(t,e,r):!isOptionObject(e)||!isOptionObject(t)?clone(e):mergeKeys(t,e,getEnumerableOwnPropertyKeys(e),r)}var mergeOptions=function(...t){const e=merge(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let r={_:{}};for(const n of t)if(n!==void 0){if(!isOptionObject(n))throw new TypeError("`"+n+"` is not an Option Object");r=merge(r,{_:n},e)}return r._};const mergeOptions$1=getDefaultExportFromCjs(mergeOptions),sha=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),sha256=from({name:"sha2-256",code:18,encode:sha("SHA-256")});var murmurHash3js={exports:{}};(function(t,e){(function(r,n){var i={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function o(u){if(!Array.isArray(u)&&!ArrayBuffer.isView(u))return!1;for(var p=0;p<u.length;p++)if(!Number.isInteger(u[p])||u[p]<0||u[p]>255)return!1;return!0}function s(u,p){return(u&65535)*p+(((u>>>16)*p&65535)<<16)}function a(u,p){return u<<p|u>>>32-p}function c(u){return u^=u>>>16,u=s(u,2246822507),u^=u>>>13,u=s(u,3266489909),u^=u>>>16,u}function f(u,p){u=[u[0]>>>16,u[0]&65535,u[1]>>>16,u[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var b=[0,0,0,0];return b[3]+=u[3]+p[3],b[2]+=b[3]>>>16,b[3]&=65535,b[2]+=u[2]+p[2],b[1]+=b[2]>>>16,b[2]&=65535,b[1]+=u[1]+p[1],b[0]+=b[1]>>>16,b[1]&=65535,b[0]+=u[0]+p[0],b[0]&=65535,[b[0]<<16|b[1],b[2]<<16|b[3]]}function l(u,p){u=[u[0]>>>16,u[0]&65535,u[1]>>>16,u[1]&65535],p=[p[0]>>>16,p[0]&65535,p[1]>>>16,p[1]&65535];var b=[0,0,0,0];return b[3]+=u[3]*p[3],b[2]+=b[3]>>>16,b[3]&=65535,b[2]+=u[2]*p[3],b[1]+=b[2]>>>16,b[2]&=65535,b[2]+=u[3]*p[2],b[1]+=b[2]>>>16,b[2]&=65535,b[1]+=u[1]*p[3],b[0]+=b[1]>>>16,b[1]&=65535,b[1]+=u[2]*p[2],b[0]+=b[1]>>>16,b[1]&=65535,b[1]+=u[3]*p[1],b[0]+=b[1]>>>16,b[1]&=65535,b[0]+=u[0]*p[3]+u[1]*p[2]+u[2]*p[1]+u[3]*p[0],b[0]&=65535,[b[0]<<16|b[1],b[2]<<16|b[3]]}function m(u,p){return p%=64,p===32?[u[1],u[0]]:p<32?[u[0]<<p|u[1]>>>32-p,u[1]<<p|u[0]>>>32-p]:(p-=32,[u[1]<<p|u[0]>>>32-p,u[0]<<p|u[1]>>>32-p])}function y(u,p){return p%=64,p===0?u:p<32?[u[0]<<p|u[1]>>>32-p,u[1]<<p]:[u[1]<<p-32,0]}function h(u,p){return[u[0]^p[0],u[1]^p[1]]}function d(u){return u=h(u,[0,u[0]>>>1]),u=l(u,[4283543511,3981806797]),u=h(u,[0,u[0]>>>1]),u=l(u,[3301882366,444984403]),u=h(u,[0,u[0]>>>1]),u}i.x86.hash32=function(u,p){if(i.inputValidation&&!o(u))return n;p=p||0;for(var b=u.length%4,A=u.length-b,D=p,T=0,g=3432918353,w=461845907,_=0;_<A;_=_+4)T=u[_]|u[_+1]<<8|u[_+2]<<16|u[_+3]<<24,T=s(T,g),T=a(T,15),T=s(T,w),D^=T,D=a(D,13),D=s(D,5)+3864292196;switch(T=0,b){case 3:T^=u[_+2]<<16;case 2:T^=u[_+1]<<8;case 1:T^=u[_],T=s(T,g),T=a(T,15),T=s(T,w),D^=T}return D^=u.length,D=c(D),D>>>0},i.x86.hash128=function(u,p){if(i.inputValidation&&!o(u))return n;p=p||0;for(var b=u.length%16,A=u.length-b,D=p,T=p,g=p,w=p,_=0,$=0,E=0,k=0,S=597399067,v=2869860233,x=951274213,C=2716044179,B=0;B<A;B=B+16)_=u[B]|u[B+1]<<8|u[B+2]<<16|u[B+3]<<24,$=u[B+4]|u[B+5]<<8|u[B+6]<<16|u[B+7]<<24,E=u[B+8]|u[B+9]<<8|u[B+10]<<16|u[B+11]<<24,k=u[B+12]|u[B+13]<<8|u[B+14]<<16|u[B+15]<<24,_=s(_,S),_=a(_,15),_=s(_,v),D^=_,D=a(D,19),D+=T,D=s(D,5)+1444728091,$=s($,v),$=a($,16),$=s($,x),T^=$,T=a(T,17),T+=g,T=s(T,5)+197830471,E=s(E,x),E=a(E,17),E=s(E,C),g^=E,g=a(g,15),g+=w,g=s(g,5)+2530024501,k=s(k,C),k=a(k,18),k=s(k,S),w^=k,w=a(w,13),w+=D,w=s(w,5)+850148119;switch(_=0,$=0,E=0,k=0,b){case 15:k^=u[B+14]<<16;case 14:k^=u[B+13]<<8;case 13:k^=u[B+12],k=s(k,C),k=a(k,18),k=s(k,S),w^=k;case 12:E^=u[B+11]<<24;case 11:E^=u[B+10]<<16;case 10:E^=u[B+9]<<8;case 9:E^=u[B+8],E=s(E,x),E=a(E,17),E=s(E,C),g^=E;case 8:$^=u[B+7]<<24;case 7:$^=u[B+6]<<16;case 6:$^=u[B+5]<<8;case 5:$^=u[B+4],$=s($,v),$=a($,16),$=s($,x),T^=$;case 4:_^=u[B+3]<<24;case 3:_^=u[B+2]<<16;case 2:_^=u[B+1]<<8;case 1:_^=u[B],_=s(_,S),_=a(_,15),_=s(_,v),D^=_}return D^=u.length,T^=u.length,g^=u.length,w^=u.length,D+=T,D+=g,D+=w,T+=D,g+=D,w+=D,D=c(D),T=c(T),g=c(g),w=c(w),D+=T,D+=g,D+=w,T+=D,g+=D,w+=D,("00000000"+(D>>>0).toString(16)).slice(-8)+("00000000"+(T>>>0).toString(16)).slice(-8)+("00000000"+(g>>>0).toString(16)).slice(-8)+("00000000"+(w>>>0).toString(16)).slice(-8)},i.x64.hash128=function(u,p){if(i.inputValidation&&!o(u))return n;p=p||0;for(var b=u.length%16,A=u.length-b,D=[0,p],T=[0,p],g=[0,0],w=[0,0],_=[2277735313,289559509],$=[1291169091,658871167],E=0;E<A;E=E+16)g=[u[E+4]|u[E+5]<<8|u[E+6]<<16|u[E+7]<<24,u[E]|u[E+1]<<8|u[E+2]<<16|u[E+3]<<24],w=[u[E+12]|u[E+13]<<8|u[E+14]<<16|u[E+15]<<24,u[E+8]|u[E+9]<<8|u[E+10]<<16|u[E+11]<<24],g=l(g,_),g=m(g,31),g=l(g,$),D=h(D,g),D=m(D,27),D=f(D,T),D=f(l(D,[0,5]),[0,1390208809]),w=l(w,$),w=m(w,33),w=l(w,_),T=h(T,w),T=m(T,31),T=f(T,D),T=f(l(T,[0,5]),[0,944331445]);switch(g=[0,0],w=[0,0],b){case 15:w=h(w,y([0,u[E+14]],48));case 14:w=h(w,y([0,u[E+13]],40));case 13:w=h(w,y([0,u[E+12]],32));case 12:w=h(w,y([0,u[E+11]],24));case 11:w=h(w,y([0,u[E+10]],16));case 10:w=h(w,y([0,u[E+9]],8));case 9:w=h(w,[0,u[E+8]]),w=l(w,$),w=m(w,33),w=l(w,_),T=h(T,w);case 8:g=h(g,y([0,u[E+7]],56));case 7:g=h(g,y([0,u[E+6]],48));case 6:g=h(g,y([0,u[E+5]],40));case 5:g=h(g,y([0,u[E+4]],32));case 4:g=h(g,y([0,u[E+3]],24));case 3:g=h(g,y([0,u[E+2]],16));case 2:g=h(g,y([0,u[E+1]],8));case 1:g=h(g,[0,u[E]]),g=l(g,_),g=m(g,31),g=l(g,$),D=h(D,g)}return D=h(D,[0,u.length]),T=h(T,[0,u.length]),D=f(D,T),T=f(T,D),D=d(D),T=d(T),D=f(D,T),T=f(T,D),("00000000"+(D[0]>>>0).toString(16)).slice(-8)+("00000000"+(D[1]>>>0).toString(16)).slice(-8)+("00000000"+(T[0]>>>0).toString(16)).slice(-8)+("00000000"+(T[1]>>>0).toString(16)).slice(-8)},t.exports&&(e=t.exports=i),e.murmurHash3=i})()})(murmurHash3js,murmurHash3js.exports);var murmurHash3jsExports=murmurHash3js.exports,murmurhash3jsRevisited=murmurHash3jsExports;const mur=getDefaultExportFromCjs(murmurhash3jsRevisited),murmur3128=from({name:"murmur3-128",code:34,encode:t=>fromHex(mur.x64.hash128(t))});async function hamtHashFn(t){return(await murmur3128.encode(t)).slice(0,8).reverse()}const defaultOptions={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hasher:sha256,leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:0x3df305dfb2a804,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,recursive:!1,hidden:!1,timeout:void 0,hamtHashFn,hamtHashCode:34,hamtBucketBits:8},defaultOptions$1=(t={})=>mergeOptions$1.bind({ignoreUndefined:!0})(defaultOptions,t);function assign(t,e){for(const r in e)Object.defineProperty(t,r,{value:e[r],enumerable:!0,configurable:!0});return t}function createError(t,e,r){if(!t||typeof t=="string")throw new TypeError("Please pass an Error to err-code");r||(r={}),typeof e=="object"&&(r=e,e=""),e&&(r.code=e);try{return assign(t,r)}catch{r.message=t.message,r.stack=t.stack;const i=function(){};return i.prototype=Object.create(Object.getPrototypeOf(t)),assign(new i,r)}}var errCode=createError;const errCode$1=getDefaultExportFromCjs(errCode);var indexMinimal={},minimal$1={},aspromise,hasRequiredAspromise;function requireAspromise(){if(hasRequiredAspromise)return aspromise;hasRequiredAspromise=1,aspromise=t;function t(e,r){for(var n=new Array(arguments.length-1),i=0,o=2,s=!0;o<arguments.length;)n[i++]=arguments[o++];return new Promise(function(c,f){n[i]=function(m){if(s)if(s=!1,m)f(m);else{for(var y=new Array(arguments.length-1),h=0;h<y.length;)y[h++]=arguments[h];c.apply(null,y)}};try{e.apply(r||null,n)}catch(l){s&&(s=!1,f(l))}})}return aspromise}var base64$3={},hasRequiredBase64;function requireBase64(){return hasRequiredBase64||(hasRequiredBase64=1,function(t){var e=t;e.length=function(a){var c=a.length;if(!c)return 0;for(var f=0;--c%4>1&&a.charAt(c)==="=";)++f;return Math.ceil(a.length*3)/4-f};for(var r=new Array(64),n=new Array(123),i=0;i<64;)n[r[i]=i<26?i+65:i<52?i+71:i<62?i-4:i-59|43]=i++;e.encode=function(a,c,f){for(var l=null,m=[],y=0,h=0,d;c<f;){var u=a[c++];switch(h){case 0:m[y++]=r[u>>2],d=(u&3)<<4,h=1;break;case 1:m[y++]=r[d|u>>4],d=(u&15)<<2,h=2;break;case 2:m[y++]=r[d|u>>6],m[y++]=r[u&63],h=0;break}y>8191&&((l||(l=[])).push(String.fromCharCode.apply(String,m)),y=0)}return h&&(m[y++]=r[d],m[y++]=61,h===1&&(m[y++]=61)),l?(y&&l.push(String.fromCharCode.apply(String,m.slice(0,y))),l.join("")):String.fromCharCode.apply(String,m.slice(0,y))};var o="invalid encoding";e.decode=function(a,c,f){for(var l=f,m=0,y,h=0;h<a.length;){var d=a.charCodeAt(h++);if(d===61&&m>1)break;if((d=n[d])===void 0)throw Error(o);switch(m){case 0:y=d,m=1;break;case 1:c[f++]=y<<2|(d&48)>>4,y=d,m=2;break;case 2:c[f++]=(y&15)<<4|(d&60)>>2,y=d,m=3;break;case 3:c[f++]=(y&3)<<6|d,m=0;break}}if(m===1)throw Error(o);return f-l},e.test=function(a){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(a)}}(base64$3)),base64$3}var eventemitter,hasRequiredEventemitter;function requireEventemitter(){if(hasRequiredEventemitter)return eventemitter;hasRequiredEventemitter=1,eventemitter=t;function t(){this._listeners={}}return t.prototype.on=function(r,n,i){return(this._listeners[r]||(this._listeners[r]=[])).push({fn:n,ctx:i||this}),this},t.prototype.off=function(r,n){if(r===void 0)this._listeners={};else if(n===void 0)this._listeners[r]=[];else for(var i=this._listeners[r],o=0;o<i.length;)i[o].fn===n?i.splice(o,1):++o;return this},t.prototype.emit=function(r){var n=this._listeners[r];if(n){for(var i=[],o=1;o<arguments.length;)i.push(arguments[o++]);for(o=0;o<n.length;)n[o].fn.apply(n[o++].ctx,i)}return this},eventemitter}var float,hasRequiredFloat;function requireFloat(){if(hasRequiredFloat)return float;hasRequiredFloat=1,float=t(t);function t(o){return typeof Float32Array<"u"?function(){var s=new Float32Array([-0]),a=new Uint8Array(s.buffer),c=a[3]===128;function f(h,d,u){s[0]=h,d[u]=a[0],d[u+1]=a[1],d[u+2]=a[2],d[u+3]=a[3]}function l(h,d,u){s[0]=h,d[u]=a[3],d[u+1]=a[2],d[u+2]=a[1],d[u+3]=a[0]}o.writeFloatLE=c?f:l,o.writeFloatBE=c?l:f;function m(h,d){return a[0]=h[d],a[1]=h[d+1],a[2]=h[d+2],a[3]=h[d+3],s[0]}function y(h,d){return a[3]=h[d],a[2]=h[d+1],a[1]=h[d+2],a[0]=h[d+3],s[0]}o.readFloatLE=c?m:y,o.readFloatBE=c?y:m}():function(){function s(c,f,l,m){var y=f<0?1:0;if(y&&(f=-f),f===0)c(1/f>0?0:2147483648,l,m);else if(isNaN(f))c(2143289344,l,m);else if(f>34028234663852886e22)c((y<<31|2139095040)>>>0,l,m);else if(f<11754943508222875e-54)c((y<<31|Math.round(f/1401298464324817e-60))>>>0,l,m);else{var h=Math.floor(Math.log(f)/Math.LN2),d=Math.round(f*Math.pow(2,-h)*8388608)&8388607;c((y<<31|h+127<<23|d)>>>0,l,m)}}o.writeFloatLE=s.bind(null,e),o.writeFloatBE=s.bind(null,r);function a(c,f,l){var m=c(f,l),y=(m>>31)*2+1,h=m>>>23&255,d=m&8388607;return h===255?d?NaN:y*(1/0):h===0?y*1401298464324817e-60*d:y*Math.pow(2,h-150)*(d+8388608)}o.readFloatLE=a.bind(null,n),o.readFloatBE=a.bind(null,i)}(),typeof Float64Array<"u"?function(){var s=new Float64Array([-0]),a=new Uint8Array(s.buffer),c=a[7]===128;function f(h,d,u){s[0]=h,d[u]=a[0],d[u+1]=a[1],d[u+2]=a[2],d[u+3]=a[3],d[u+4]=a[4],d[u+5]=a[5],d[u+6]=a[6],d[u+7]=a[7]}function l(h,d,u){s[0]=h,d[u]=a[7],d[u+1]=a[6],d[u+2]=a[5],d[u+3]=a[4],d[u+4]=a[3],d[u+5]=a[2],d[u+6]=a[1],d[u+7]=a[0]}o.writeDoubleLE=c?f:l,o.writeDoubleBE=c?l:f;function m(h,d){return a[0]=h[d],a[1]=h[d+1],a[2]=h[d+2],a[3]=h[d+3],a[4]=h[d+4],a[5]=h[d+5],a[6]=h[d+6],a[7]=h[d+7],s[0]}function y(h,d){return a[7]=h[d],a[6]=h[d+1],a[5]=h[d+2],a[4]=h[d+3],a[3]=h[d+4],a[2]=h[d+5],a[1]=h[d+6],a[0]=h[d+7],s[0]}o.readDoubleLE=c?m:y,o.readDoubleBE=c?y:m}():function(){function s(c,f,l,m,y,h){var d=m<0?1:0;if(d&&(m=-m),m===0)c(0,y,h+f),c(1/m>0?0:2147483648,y,h+l);else if(isNaN(m))c(0,y,h+f),c(2146959360,y,h+l);else if(m>17976931348623157e292)c(0,y,h+f),c((d<<31|2146435072)>>>0,y,h+l);else{var u;if(m<22250738585072014e-324)u=m/5e-324,c(u>>>0,y,h+f),c((d<<31|u/4294967296)>>>0,y,h+l);else{var p=Math.floor(Math.log(m)/Math.LN2);p===1024&&(p=1023),u=m*Math.pow(2,-p),c(u*4503599627370496>>>0,y,h+f),c((d<<31|p+1023<<20|u*1048576&1048575)>>>0,y,h+l)}}}o.writeDoubleLE=s.bind(null,e,0,4),o.writeDoubleBE=s.bind(null,r,4,0);function a(c,f,l,m,y){var h=c(m,y+f),d=c(m,y+l),u=(d>>31)*2+1,p=d>>>20&2047,b=4294967296*(d&1048575)+h;return p===2047?b?NaN:u*(1/0):p===0?u*5e-324*b:u*Math.pow(2,p-1075)*(b+4503599627370496)}o.readDoubleLE=a.bind(null,n,0,4),o.readDoubleBE=a.bind(null,i,4,0)}(),o}function e(o,s,a){s[a]=o&255,s[a+1]=o>>>8&255,s[a+2]=o>>>16&255,s[a+3]=o>>>24}function r(o,s,a){s[a]=o>>>24,s[a+1]=o>>>16&255,s[a+2]=o>>>8&255,s[a+3]=o&255}function n(o,s){return(o[s]|o[s+1]<<8|o[s+2]<<16|o[s+3]<<24)>>>0}function i(o,s){return(o[s]<<24|o[s+1]<<16|o[s+2]<<8|o[s+3])>>>0}return float}var inquire_1,hasRequiredInquire;function requireInquire(){if(hasRequiredInquire)return inquire_1;hasRequiredInquire=1,inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(t){}return null}return inquire_1}var utf8$2={},hasRequiredUtf8;function requireUtf8(){return hasRequiredUtf8||(hasRequiredUtf8=1,function(t){var e=t;e.length=function(n){for(var i=0,o=0,s=0;s<n.length;++s)o=n.charCodeAt(s),o<128?i+=1:o<2048?i+=2:(o&64512)===55296&&(n.charCodeAt(s+1)&64512)===56320?(++s,i+=4):i+=3;return i},e.read=function(n,i,o){var s=o-i;if(s<1)return"";for(var a=null,c=[],f=0,l;i<o;)l=n[i++],l<128?c[f++]=l:l>191&&l<224?c[f++]=(l&31)<<6|n[i++]&63:l>239&&l<365?(l=((l&7)<<18|(n[i++]&63)<<12|(n[i++]&63)<<6|n[i++]&63)-65536,c[f++]=55296+(l>>10),c[f++]=56320+(l&1023)):c[f++]=(l&15)<<12|(n[i++]&63)<<6|n[i++]&63,f>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,c)),f=0);return a?(f&&a.push(String.fromCharCode.apply(String,c.slice(0,f))),a.join("")):String.fromCharCode.apply(String,c.slice(0,f))},e.write=function(n,i,o){for(var s=o,a,c,f=0;f<n.length;++f)a=n.charCodeAt(f),a<128?i[o++]=a:a<2048?(i[o++]=a>>6|192,i[o++]=a&63|128):(a&64512)===55296&&((c=n.charCodeAt(f+1))&64512)===56320?(a=65536+((a&1023)<<10)+(c&1023),++f,i[o++]=a>>18|240,i[o++]=a>>12&63|128,i[o++]=a>>6&63|128,i[o++]=a&63|128):(i[o++]=a>>12|224,i[o++]=a>>6&63|128,i[o++]=a&63|128);return o-s}}(utf8$2)),utf8$2}var pool_1,hasRequiredPool;function requirePool(){if(hasRequiredPool)return pool_1;hasRequiredPool=1,pool_1=t;function t(e,r,n){var i=n||8192,o=i>>>1,s=null,a=i;return function(f){if(f<1||f>o)return e(f);a+f>i&&(s=e(i),a=0);var l=r.call(s,a,a+=f);return a&7&&(a=(a|7)+1),l}}return pool_1}var longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=e;var t=requireMinimal();function e(o,s){this.lo=o>>>0,this.hi=s>>>0}var r=e.zero=new e(0,0);r.toNumber=function(){return 0},r.zzEncode=r.zzDecode=function(){return this},r.length=function(){return 1};var n=e.zeroHash="\0\0\0\0\0\0\0\0";e.fromNumber=function(s){if(s===0)return r;var a=s<0;a&&(s=-s);var c=s>>>0,f=(s-c)/4294967296>>>0;return a&&(f=~f>>>0,c=~c>>>0,++c>4294967295&&(c=0,++f>4294967295&&(f=0))),new e(c,f)},e.from=function(s){if(typeof s=="number")return e.fromNumber(s);if(t.isString(s))if(t.Long)s=t.Long.fromString(s);else return e.fromNumber(parseInt(s,10));return s.low||s.high?new e(s.low>>>0,s.high>>>0):r},e.prototype.toNumber=function(s){if(!s&&this.hi>>>31){var a=~this.lo+1>>>0,c=~this.hi>>>0;return a||(c=c+1>>>0),-(a+c*4294967296)}return this.lo+this.hi*4294967296},e.prototype.toLong=function(s){return t.Long?new t.Long(this.lo|0,this.hi|0,!!s):{low:this.lo|0,high:this.hi|0,unsigned:!!s}};var i=String.prototype.charCodeAt;return e.fromHash=function(s){return s===n?r:new e((i.call(s,0)|i.call(s,1)<<8|i.call(s,2)<<16|i.call(s,3)<<24)>>>0,(i.call(s,4)|i.call(s,5)<<8|i.call(s,6)<<16|i.call(s,7)<<24)>>>0)},e.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},e.prototype.zzEncode=function(){var s=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^s)>>>0,this.lo=(this.lo<<1^s)>>>0,this},e.prototype.zzDecode=function(){var s=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^s)>>>0,this.hi=(this.hi>>>1^s)>>>0,this},e.prototype.length=function(){var s=this.lo,a=(this.lo>>>28|this.hi<<4)>>>0,c=this.hi>>>24;return c===0?a===0?s<16384?s<128?1:2:s<2097152?3:4:a<16384?a<128?5:6:a<2097152?7:8:c<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(t){var e=t;e.asPromise=requireAspromise(),e.base64=requireBase64(),e.EventEmitter=requireEventemitter(),e.float=requireFloat(),e.inquire=requireInquire(),e.utf8=requireUtf8(),e.pool=requirePool(),e.LongBits=requireLongbits(),e.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),e.global=e.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,e.emptyArray=Object.freeze?Object.freeze([]):[],e.emptyObject=Object.freeze?Object.freeze({}):{},e.isInteger=Number.isInteger||function(o){return typeof o=="number"&&isFinite(o)&&Math.floor(o)===o},e.isString=function(o){return typeof o=="string"||o instanceof String},e.isObject=function(o){return o&&typeof o=="object"},e.isset=e.isSet=function(o,s){var a=o[s];return a!=null&&o.hasOwnProperty(s)?typeof a!="object"||(Array.isArray(a)?a.length:Object.keys(a).length)>0:!1},e.Buffer=function(){try{var i=e.inquire("buffer").Buffer;return i.prototype.utf8Write?i:null}catch{return null}}(),e._Buffer_from=null,e._Buffer_allocUnsafe=null,e.newBuffer=function(o){return typeof o=="number"?e.Buffer?e._Buffer_allocUnsafe(o):new e.Array(o):e.Buffer?e._Buffer_from(o):typeof Uint8Array>"u"?o:new Uint8Array(o)},e.Array=typeof Uint8Array<"u"?Uint8Array:Array,e.Long=e.global.dcodeIO&&e.global.dcodeIO.Long||e.global.Long||e.inquire("long"),e.key2Re=/^true|false|0|1$/,e.key32Re=/^-?(?:0|[1-9][0-9]*)$/,e.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,e.longToHash=function(o){return o?e.LongBits.from(o).toHash():e.LongBits.zeroHash},e.longFromHash=function(o,s){var a=e.LongBits.fromHash(o);return e.Long?e.Long.fromBits(a.lo,a.hi,s):a.toNumber(!!s)};function r(i,o,s){for(var a=Object.keys(o),c=0;c<a.length;++c)(i[a[c]]===void 0||!s)&&(i[a[c]]=o[a[c]]);return i}e.merge=r,e.lcFirst=function(o){return o.charAt(0).toLowerCase()+o.substring(1)};function n(i){function o(s,a){if(!(this instanceof o))return new o(s,a);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,o):Object.defineProperty(this,"stack",{value:new Error().stack||""}),a&&r(this,a)}return(o.prototype=Object.create(Error.prototype)).constructor=o,Object.defineProperty(o.prototype,"name",{get:function(){return i}}),o.prototype.toString=function(){return this.name+": "+this.message},o}e.newError=n,e.ProtocolError=n("ProtocolError"),e.oneOfGetter=function(o){for(var s={},a=0;a<o.length;++a)s[o[a]]=1;return function(){for(var c=Object.keys(this),f=c.length-1;f>-1;--f)if(s[c[f]]===1&&this[c[f]]!==void 0&&this[c[f]]!==null)return c[f]}},e.oneOfSetter=function(o){return function(s){for(var a=0;a<o.length;++a)o[a]!==s&&delete this[o[a]]}},e.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},e._configure=function(){var i=e.Buffer;if(!i){e._Buffer_from=e._Buffer_allocUnsafe=null;return}e._Buffer_from=i.from!==Uint8Array.from&&i.from||function(s,a){return new i(s,a)},e._Buffer_allocUnsafe=i.allocUnsafe||function(s){return new i(s)}}}(minimal$1)),minimal$1}var writer=Writer$1,util$4=requireMinimal(),BufferWriter$1,LongBits$1=util$4.LongBits,base64$2=util$4.base64,utf8$1=util$4.utf8;function Op(t,e,r){this.fn=t,this.len=e,this.next=void 0,this.val=r}function noop(){}function State(t){this.head=t.head,this.tail=t.tail,this.len=t.len,this.next=t.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$2=function t(){return util$4.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create$2();Writer$1.alloc=function t(e){return new util$4.Array(e)};util$4.Array!==Array&&(Writer$1.alloc=util$4.pool(Writer$1.alloc,util$4.Array.prototype.subarray));Writer$1.prototype._push=function t(e,r,n){return this.tail=this.tail.next=new Op(e,r,n),this.len+=r,this};function writeByte(t,e,r){e[r]=t&255}function writeVarint32(t,e,r){for(;t>127;)e[r++]=t&127|128,t>>>=7;e[r]=t}function VarintOp(t,e){this.len=t,this.next=void 0,this.val=e}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function t(e){return this.len+=(this.tail=this.tail.next=new VarintOp((e=e>>>0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this};Writer$1.prototype.int32=function t(e){return e<0?this._push(writeVarint64,10,LongBits$1.fromNumber(e)):this.uint32(e)};Writer$1.prototype.sint32=function t(e){return this.uint32((e<<1^e>>31)>>>0)};function writeVarint64(t,e,r){for(;t.hi;)e[r++]=t.lo&127|128,t.lo=(t.lo>>>7|t.hi<<25)>>>0,t.hi>>>=7;for(;t.lo>127;)e[r++]=t.lo&127|128,t.lo=t.lo>>>7;e[r++]=t.lo}Writer$1.prototype.uint64=function t(e){var r=LongBits$1.from(e);return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function t(e){var r=LongBits$1.from(e).zzEncode();return this._push(writeVarint64,r.length(),r)};Writer$1.prototype.bool=function t(e){return this._push(writeByte,1,e?1:0)};function writeFixed32(t,e,r){e[r]=t&255,e[r+1]=t>>>8&255,e[r+2]=t>>>16&255,e[r+3]=t>>>24}Writer$1.prototype.fixed32=function t(e){return this._push(writeFixed32,4,e>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function t(e){var r=LongBits$1.from(e);return this._push(writeFixed32,4,r.lo)._push(writeFixed32,4,r.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function t(e){return this._push(util$4.float.writeFloatLE,4,e)};Writer$1.prototype.double=function t(e){return this._push(util$4.float.writeDoubleLE,8,e)};var writeBytes=util$4.Array.prototype.set?function t(e,r,n){r.set(e,n)}:function t(e,r,n){for(var i=0;i<e.length;++i)r[n+i]=e[i]};Writer$1.prototype.bytes=function t(e){var r=e.length>>>0;if(!r)return this._push(writeByte,1,0);if(util$4.isString(e)){var n=Writer$1.alloc(r=base64$2.length(e));base64$2.decode(e,n,0),e=n}return this.uint32(r)._push(writeBytes,r,e)};Writer$1.prototype.string=function t(e){var r=utf8$1.length(e);return r?this.uint32(r)._push(utf8$1.write,r,e):this._push(writeByte,1,0)};Writer$1.prototype.fork=function t(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this};Writer$1.prototype.reset=function t(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this};Writer$1.prototype.ldelim=function t(){var e=this.head,r=this.tail,n=this.len;return this.reset().uint32(n),n&&(this.tail.next=e.next,this.tail=r,this.len+=n),this};Writer$1.prototype.finish=function t(){for(var e=this.head.next,r=this.constructor.alloc(this.len),n=0;e;)e.fn(e.val,r,n),n+=e.len,e=e.next;return r};Writer$1._configure=function(t){BufferWriter$1=t,Writer$1.create=create$2(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$3=requireMinimal();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$3._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$3.Buffer&&util$3.Buffer.prototype instanceof Uint8Array&&util$3.Buffer.prototype.set.name==="set"?function(e,r,n){r.set(e,n)}:function(e,r,n){if(e.copy)e.copy(r,n,0,e.length);else for(var i=0;i<e.length;)r[n++]=e[i++]}};BufferWriter.prototype.bytes=function t(e){util$3.isString(e)&&(e=util$3._Buffer_from(e,"base64"));var r=e.length>>>0;return this.uint32(r),r&&this._push(BufferWriter.writeBytesBuffer,r,e),this};function writeStringBuffer(t,e,r){t.length<40?util$3.utf8.write(t,e,r):e.utf8Write?e.utf8Write(t,r):e.write(t,r)}BufferWriter.prototype.string=function t(e){var r=util$3.Buffer.byteLength(e);return this.uint32(r),r&&this._push(writeStringBuffer,r,e),this};BufferWriter._configure();var reader=Reader$1,util$2=requireMinimal(),BufferReader$1,LongBits=util$2.LongBits,utf8=util$2.utf8;function indexOutOfRange(t,e){return RangeError("index out of range: "+t.pos+" + "+(e||1)+" > "+t.len)}function Reader$1(t){this.buf=t,this.pos=0,this.len=t.length}var create_array=typeof Uint8Array<"u"?function t(e){if(e instanceof Uint8Array||Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")}:function t(e){if(Array.isArray(e))return new Reader$1(e);throw Error("illegal buffer")},create$1=function t(){return util$2.Buffer?function(r){return(Reader$1.create=function(i){return util$2.Buffer.isBuffer(i)?new BufferReader$1(i):create_array(i)})(r)}:create_array};Reader$1.create=create$1();Reader$1.prototype._slice=util$2.Array.prototype.subarray||util$2.Array.prototype.slice;Reader$1.prototype.uint32=function t(){var e=4294967295;return function(){if(e=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(e=(e|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(e=(e|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return e;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return e}}();Reader$1.prototype.int32=function t(){return this.uint32()|0};Reader$1.prototype.sint32=function t(){var e=this.uint32();return e>>>1^-(e&1)|0};function readLongVarint(){var t=new LongBits(0,0),e=0;if(this.len-this.pos>4){for(;e<4;++e)if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t;if(t.lo=(t.lo|(this.buf[this.pos]&127)<<28)>>>0,t.hi=(t.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return t;e=0}else{for(;e<3;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.lo=(t.lo|(this.buf[this.pos]&127)<<e*7)>>>0,this.buf[this.pos++]<128)return t}return t.lo=(t.lo|(this.buf[this.pos++]&127)<<e*7)>>>0,t}if(this.len-this.pos>4){for(;e<5;++e)if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}else for(;e<5;++e){if(this.pos>=this.len)throw indexOutOfRange(this);if(t.hi=(t.hi|(this.buf[this.pos]&127)<<e*7+3)>>>0,this.buf[this.pos++]<128)return t}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function t(){return this.uint32()!==0};function readFixed32_end(t,e){return(t[e-4]|t[e-3]<<8|t[e-2]<<16|t[e-1]<<24)>>>0}Reader$1.prototype.fixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function t(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e};Reader$1.prototype.double=function t(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var e=util$2.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e};Reader$1.prototype.bytes=function t(){var e=this.uint32(),r=this.pos,n=this.pos+e;if(n>this.len)throw indexOutOfRange(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(r,n):r===n?new this.buf.constructor(0):this._slice.call(this.buf,r,n)};Reader$1.prototype.string=function t(){var e=this.bytes();return utf8.read(e,0,e.length)};Reader$1.prototype.skip=function t(e){if(typeof e=="number"){if(this.pos+e>this.len)throw indexOutOfRange(this,e);this.pos+=e}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(t){switch(t){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(t=this.uint32()&7)!==4;)this.skipType(t);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+t+" at offset "+this.pos)}return this};Reader$1._configure=function(t){BufferReader$1=t,Reader$1.create=create$1(),BufferReader$1._configure();var e=util$2.Long?"toLong":"toNumber";util$2.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[e](!1)},uint64:function(){return readLongVarint.call(this)[e](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[e](!1)},fixed64:function(){return readFixed64.call(this)[e](!0)},sfixed64:function(){return readFixed64.call(this)[e](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$1=requireMinimal();function BufferReader(t){Reader.call(this,t)}BufferReader._configure=function(){util$1.Buffer&&(BufferReader.prototype._slice=util$1.Buffer.prototype.slice)};BufferReader.prototype.string=function t(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))};BufferReader._configure();var rpc={},service=Service,util=requireMinimal();(Service.prototype=Object.create(util.EventEmitter.prototype)).constructor=Service;function Service(t,e,r){if(typeof t!="function")throw TypeError("rpcImpl must be a function");util.EventEmitter.call(this),this.rpcImpl=t,this.requestDelimited=!!e,this.responseDelimited=!!r}Service.prototype.rpcCall=function t(e,r,n,i,o){if(!i)throw TypeError("request must be specified");var s=this;if(!o)return util.asPromise(t,s,e,r,n,i);if(!s.rpcImpl){setTimeout(function(){o(Error("already ended"))},0);return}try{return s.rpcImpl(e,r[s.requestDelimited?"encodeDelimited":"encode"](i).finish(),function(c,f){if(c)return s.emit("error",c,e),o(c);if(f===null){s.end(!0);return}if(!(f instanceof n))try{f=n[s.responseDelimited?"decodeDelimited":"decode"](f)}catch(l){return s.emit("error",l,e),o(l)}return s.emit("data",f,e),o(null,f)})}catch(a){s.emit("error",a,e),setTimeout(function(){o(a)},0);return}};Service.prototype.end=function t(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};(function(t){var e=t;e.Service=service})(rpc);var roots={};(function(t){var e=t;e.build="minimal",e.Writer=writer,e.BufferWriter=writer_buffer,e.Reader=reader,e.BufferReader=reader_buffer,e.util=requireMinimal(),e.rpc=rpc,e.roots=roots,e.configure=r;function r(){e.util._configure(),e.Writer._configure(e.BufferWriter),e.Reader._configure(e.BufferReader)}r()})(indexMinimal);var minimal=indexMinimal;const $protobuf=getDefaultExportFromCjs(minimal),$Reader=$protobuf.Reader,$Writer=$protobuf.Writer,$util=$protobuf.util,$root=$protobuf.roots["ipfs-unixfs"]||($protobuf.roots["ipfs-unixfs"]={}),Data=$root.Data=(()=>{function t(e){if(this.blocksizes=[],e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Type=0,t.prototype.Data=$util.newBuffer([]),t.prototype.filesize=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.blocksizes=$util.emptyArray,t.prototype.hashType=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.fanout=$util.Long?$util.Long.fromBits(0,0,!0):0,t.prototype.mode=0,t.prototype.mtime=null,t.encode=function(r,n){if(n||(n=$Writer.create()),n.uint32(8).int32(r.Type),r.Data!=null&&Object.hasOwnProperty.call(r,"Data")&&n.uint32(18).bytes(r.Data),r.filesize!=null&&Object.hasOwnProperty.call(r,"filesize")&&n.uint32(24).uint64(r.filesize),r.blocksizes!=null&&r.blocksizes.length)for(var i=0;i<r.blocksizes.length;++i)n.uint32(32).uint64(r.blocksizes[i]);return r.hashType!=null&&Object.hasOwnProperty.call(r,"hashType")&&n.uint32(40).uint64(r.hashType),r.fanout!=null&&Object.hasOwnProperty.call(r,"fanout")&&n.uint32(48).uint64(r.fanout),r.mode!=null&&Object.hasOwnProperty.call(r,"mode")&&n.uint32(56).uint32(r.mode),r.mtime!=null&&Object.hasOwnProperty.call(r,"mtime")&&$root.UnixTime.encode(r.mtime,n.uint32(66).fork()).ldelim(),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var i=n===void 0?r.len:r.pos+n,o=new $root.Data;r.pos<i;){var s=r.uint32();switch(s>>>3){case 1:o.Type=r.int32();break;case 2:o.Data=r.bytes();break;case 3:o.filesize=r.uint64();break;case 4:if(o.blocksizes&&o.blocksizes.length||(o.blocksizes=[]),(s&7)===2)for(var a=r.uint32()+r.pos;r.pos<a;)o.blocksizes.push(r.uint64());else o.blocksizes.push(r.uint64());break;case 5:o.hashType=r.uint64();break;case 6:o.fanout=r.uint64();break;case 7:o.mode=r.uint32();break;case 8:o.mtime=$root.UnixTime.decode(r,r.uint32());break;default:r.skipType(s&7);break}}if(!o.hasOwnProperty("Type"))throw $util.ProtocolError("missing required 'Type'",{instance:o});return o},t.fromObject=function(r){if(r instanceof $root.Data)return r;var n=new $root.Data;switch(r.Type){case"Raw":case 0:n.Type=0;break;case"Directory":case 1:n.Type=1;break;case"File":case 2:n.Type=2;break;case"Metadata":case 3:n.Type=3;break;case"Symlink":case 4:n.Type=4;break;case"HAMTShard":case 5:n.Type=5;break}if(r.Data!=null&&(typeof r.Data=="string"?$util.base64.decode(r.Data,n.Data=$util.newBuffer($util.base64.length(r.Data)),0):r.Data.length&&(n.Data=r.Data)),r.filesize!=null&&($util.Long?(n.filesize=$util.Long.fromValue(r.filesize)).unsigned=!0:typeof r.filesize=="string"?n.filesize=parseInt(r.filesize,10):typeof r.filesize=="number"?n.filesize=r.filesize:typeof r.filesize=="object"&&(n.filesize=new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0))),r.blocksizes){if(!Array.isArray(r.blocksizes))throw TypeError(".Data.blocksizes: array expected");n.blocksizes=[];for(var i=0;i<r.blocksizes.length;++i)$util.Long?(n.blocksizes[i]=$util.Long.fromValue(r.blocksizes[i])).unsigned=!0:typeof r.blocksizes[i]=="string"?n.blocksizes[i]=parseInt(r.blocksizes[i],10):typeof r.blocksizes[i]=="number"?n.blocksizes[i]=r.blocksizes[i]:typeof r.blocksizes[i]=="object"&&(n.blocksizes[i]=new $util.LongBits(r.blocksizes[i].low>>>0,r.blocksizes[i].high>>>0).toNumber(!0))}if(r.hashType!=null&&($util.Long?(n.hashType=$util.Long.fromValue(r.hashType)).unsigned=!0:typeof r.hashType=="string"?n.hashType=parseInt(r.hashType,10):typeof r.hashType=="number"?n.hashType=r.hashType:typeof r.hashType=="object"&&(n.hashType=new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0))),r.fanout!=null&&($util.Long?(n.fanout=$util.Long.fromValue(r.fanout)).unsigned=!0:typeof r.fanout=="string"?n.fanout=parseInt(r.fanout,10):typeof r.fanout=="number"?n.fanout=r.fanout:typeof r.fanout=="object"&&(n.fanout=new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0))),r.mode!=null&&(n.mode=r.mode>>>0),r.mtime!=null){if(typeof r.mtime!="object")throw TypeError(".Data.mtime: object expected");n.mtime=$root.UnixTime.fromObject(r.mtime)}return n},t.toObject=function(r,n){n||(n={});var i={};if((n.arrays||n.defaults)&&(i.blocksizes=[]),n.defaults){if(i.Type=n.enums===String?"Raw":0,n.bytes===String?i.Data="":(i.Data=[],n.bytes!==Array&&(i.Data=$util.newBuffer(i.Data))),$util.Long){var o=new $util.Long(0,0,!0);i.filesize=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else i.filesize=n.longs===String?"0":0;if($util.Long){var o=new $util.Long(0,0,!0);i.hashType=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else i.hashType=n.longs===String?"0":0;if($util.Long){var o=new $util.Long(0,0,!0);i.fanout=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else i.fanout=n.longs===String?"0":0;i.mode=0,i.mtime=null}if(r.Type!=null&&r.hasOwnProperty("Type")&&(i.Type=n.enums===String?$root.Data.DataType[r.Type]:r.Type),r.Data!=null&&r.hasOwnProperty("Data")&&(i.Data=n.bytes===String?$util.base64.encode(r.Data,0,r.Data.length):n.bytes===Array?Array.prototype.slice.call(r.Data):r.Data),r.filesize!=null&&r.hasOwnProperty("filesize")&&(typeof r.filesize=="number"?i.filesize=n.longs===String?String(r.filesize):r.filesize:i.filesize=n.longs===String?$util.Long.prototype.toString.call(r.filesize):n.longs===Number?new $util.LongBits(r.filesize.low>>>0,r.filesize.high>>>0).toNumber(!0):r.filesize),r.blocksizes&&r.blocksizes.length){i.blocksizes=[];for(var s=0;s<r.blocksizes.length;++s)typeof r.blocksizes[s]=="number"?i.blocksizes[s]=n.longs===String?String(r.blocksizes[s]):r.blocksizes[s]:i.blocksizes[s]=n.longs===String?$util.Long.prototype.toString.call(r.blocksizes[s]):n.longs===Number?new $util.LongBits(r.blocksizes[s].low>>>0,r.blocksizes[s].high>>>0).toNumber(!0):r.blocksizes[s]}return r.hashType!=null&&r.hasOwnProperty("hashType")&&(typeof r.hashType=="number"?i.hashType=n.longs===String?String(r.hashType):r.hashType:i.hashType=n.longs===String?$util.Long.prototype.toString.call(r.hashType):n.longs===Number?new $util.LongBits(r.hashType.low>>>0,r.hashType.high>>>0).toNumber(!0):r.hashType),r.fanout!=null&&r.hasOwnProperty("fanout")&&(typeof r.fanout=="number"?i.fanout=n.longs===String?String(r.fanout):r.fanout:i.fanout=n.longs===String?$util.Long.prototype.toString.call(r.fanout):n.longs===Number?new $util.LongBits(r.fanout.low>>>0,r.fanout.high>>>0).toNumber(!0):r.fanout),r.mode!=null&&r.hasOwnProperty("mode")&&(i.mode=r.mode),r.mtime!=null&&r.hasOwnProperty("mtime")&&(i.mtime=$root.UnixTime.toObject(r.mtime,n)),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t.DataType=function(){const e={},r=Object.create(e);return r[e[0]="Raw"]=0,r[e[1]="Directory"]=1,r[e[2]="File"]=2,r[e[3]="Metadata"]=3,r[e[4]="Symlink"]=4,r[e[5]="HAMTShard"]=5,r}(),t})();$root.UnixTime=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.Seconds=$util.Long?$util.Long.fromBits(0,0,!1):0,t.prototype.FractionalNanoseconds=0,t.encode=function(r,n){return n||(n=$Writer.create()),n.uint32(8).int64(r.Seconds),r.FractionalNanoseconds!=null&&Object.hasOwnProperty.call(r,"FractionalNanoseconds")&&n.uint32(21).fixed32(r.FractionalNanoseconds),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var i=n===void 0?r.len:r.pos+n,o=new $root.UnixTime;r.pos<i;){var s=r.uint32();switch(s>>>3){case 1:o.Seconds=r.int64();break;case 2:o.FractionalNanoseconds=r.fixed32();break;default:r.skipType(s&7);break}}if(!o.hasOwnProperty("Seconds"))throw $util.ProtocolError("missing required 'Seconds'",{instance:o});return o},t.fromObject=function(r){if(r instanceof $root.UnixTime)return r;var n=new $root.UnixTime;return r.Seconds!=null&&($util.Long?(n.Seconds=$util.Long.fromValue(r.Seconds)).unsigned=!1:typeof r.Seconds=="string"?n.Seconds=parseInt(r.Seconds,10):typeof r.Seconds=="number"?n.Seconds=r.Seconds:typeof r.Seconds=="object"&&(n.Seconds=new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber())),r.FractionalNanoseconds!=null&&(n.FractionalNanoseconds=r.FractionalNanoseconds>>>0),n},t.toObject=function(r,n){n||(n={});var i={};if(n.defaults){if($util.Long){var o=new $util.Long(0,0,!1);i.Seconds=n.longs===String?o.toString():n.longs===Number?o.toNumber():o}else i.Seconds=n.longs===String?"0":0;i.FractionalNanoseconds=0}return r.Seconds!=null&&r.hasOwnProperty("Seconds")&&(typeof r.Seconds=="number"?i.Seconds=n.longs===String?String(r.Seconds):r.Seconds:i.Seconds=n.longs===String?$util.Long.prototype.toString.call(r.Seconds):n.longs===Number?new $util.LongBits(r.Seconds.low>>>0,r.Seconds.high>>>0).toNumber():r.Seconds),r.FractionalNanoseconds!=null&&r.hasOwnProperty("FractionalNanoseconds")&&(i.FractionalNanoseconds=r.FractionalNanoseconds),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();$root.Metadata=(()=>{function t(e){if(e)for(var r=Object.keys(e),n=0;n<r.length;++n)e[r[n]]!=null&&(this[r[n]]=e[r[n]])}return t.prototype.MimeType="",t.encode=function(r,n){return n||(n=$Writer.create()),r.MimeType!=null&&Object.hasOwnProperty.call(r,"MimeType")&&n.uint32(10).string(r.MimeType),n},t.decode=function(r,n){r instanceof $Reader||(r=$Reader.create(r));for(var i=n===void 0?r.len:r.pos+n,o=new $root.Metadata;r.pos<i;){var s=r.uint32();switch(s>>>3){case 1:o.MimeType=r.string();break;default:r.skipType(s&7);break}}return o},t.fromObject=function(r){if(r instanceof $root.Metadata)return r;var n=new $root.Metadata;return r.MimeType!=null&&(n.MimeType=String(r.MimeType)),n},t.toObject=function(r,n){n||(n={});var i={};return n.defaults&&(i.MimeType=""),r.MimeType!=null&&r.hasOwnProperty("MimeType")&&(i.MimeType=r.MimeType),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,$protobuf.util.toJSONOptions)},t})();const PBData=Data,types=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],dirTypes=["directory","hamt-sharded-directory"],DEFAULT_FILE_MODE=parseInt("0644",8),DEFAULT_DIRECTORY_MODE=parseInt("0755",8);function parseMode(t){if(t!=null)return typeof t=="number"?t&4095:(t=t.toString(),t.substring(0,1)==="0"?parseInt(t,8)&4095:parseInt(t,10)&4095)}function parseMtime(t){if(t==null)return;let e;if(t.secs!=null&&(e={secs:t.secs,nsecs:t.nsecs}),t.Seconds!=null&&(e={secs:t.Seconds,nsecs:t.FractionalNanoseconds}),Array.isArray(t)&&(e={secs:t[0],nsecs:t[1]}),t instanceof Date){const r=t.getTime(),n=Math.floor(r/1e3);e={secs:n,nsecs:(r-n*1e3)*1e3}}if(Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw errCode$1(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}class UnixFS{static unmarshal(e){const r=PBData.decode(e),n=PBData.toObject(r,{defaults:!1,arrays:!0,longs:Number,objects:!1}),i=new UnixFS({type:types[n.Type],data:n.Data,blockSizes:n.blocksizes,mode:n.mode,mtime:n.mtime?{secs:n.mtime.Seconds,nsecs:n.mtime.FractionalNanoseconds}:void 0});return i._originalMode=n.mode||0,i}constructor(e={type:"file"}){const{type:r,data:n,blockSizes:i,hashType:o,fanout:s,mtime:a,mode:c}=e;if(r&&!types.includes(r))throw errCode$1(new Error("Type: "+r+" is not valid"),"ERR_INVALID_TYPE");this.type=r||"file",this.data=n,this.hashType=o,this.fanout=s,this.blockSizes=i||[],this._originalMode=0,this.mode=parseMode(c),a&&(this.mtime=parseMtime(a),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?DEFAULT_DIRECTORY_MODE:DEFAULT_FILE_MODE;const r=parseMode(e);r!==void 0&&(this._mode=r)}get mode(){return this._mode}isDirectory(){return!!(this.type&&dirTypes.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach(r=>{e+=r}),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=PBData.DataType.Raw;break;case"directory":e=PBData.DataType.Directory;break;case"file":e=PBData.DataType.File;break;case"metadata":e=PBData.DataType.Metadata;break;case"symlink":e=PBData.DataType.Symlink;break;case"hamt-sharded-directory":e=PBData.DataType.HAMTShard;break;default:throw errCode$1(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let r=this.data;(!this.data||!this.data.length)&&(r=void 0);let n;this.mode!=null&&(n=this._originalMode&4294963200|(parseMode(this.mode)||0),n===DEFAULT_FILE_MODE&&!this.isDirectory()&&(n=void 0),n===DEFAULT_DIRECTORY_MODE&&this.isDirectory()&&(n=void 0));let i;if(this.mtime!=null){const s=parseMtime(this.mtime);s&&(i={Seconds:s.secs,FractionalNanoseconds:s.nsecs},i.FractionalNanoseconds===0&&delete i.FractionalNanoseconds)}const o={Type:e,Data:r,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:n,mtime:i};return PBData.encode(o).finish()}}const persist=async(t,e,r)=>{r.codec||(r.codec=dagPb),r.hasher||(r.hasher=sha256),r.cidVersion===void 0&&(r.cidVersion=1),r.codec===dagPb&&r.hasher!==sha256&&(r.cidVersion=1);const n=await r.hasher.digest(t),i=CID.create(r.cidVersion,r.codec.code,n);return r.onlyHash||await e.put(i,t,{signal:r.signal}),i},dirBuilder=async(t,e,r)=>{const n=new UnixFS({type:"directory",mtime:t.mtime,mode:t.mode}),i=encode$1(prepare({Data:n.marshal()})),o=await persist(i,e,r),s=t.path;return{cid:o,path:s,unixfs:n,size:i.length}},all=async t=>{const e=[];for await(const r of t)e.push(r);return e};var itAll=all;const all$1=getDefaultExportFromCjs(itAll);async function flat(t,e){return e(await all$1(t))}function balanced(t,e,r){return reduceToParents(t,e,r)}async function reduceToParents(t,e,r){const n=[];for await(const i of batch$2(t,r.maxChildrenPerNode))n.push(await e(i));return n.length>1?reduceToParents(n,e,r):n[0]}async function trickleStream(t,e,r){const n=new Root(r.layerRepeat);let i=0,o=1,s=n;for await(const a of batch$2(t,r.maxChildrenPerNode))s.isFull()&&(s!==n&&n.addChild(await s.reduce(e)),i&&i%r.layerRepeat===0&&o++,s=new SubTree(o,r.layerRepeat,i),i++),s.append(a);return s&&s!==n&&n.addChild(await s.reduce(e)),n.reduce(e)}class SubTree{constructor(e,r,n=0){this.maxDepth=e,this.layerRepeat=r,this.currentDepth=1,this.iteration=n,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:e,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;const e=this._findParent(this.node,this.currentDepth);return e?(this._addNextNodeToParent(e),!1):!0}_addNextNodeToParent(e){this.parent=e;const r={children:[],depth:e.depth+1,parent:e,maxDepth:this.maxDepth,maxChildren:Math.floor(e.children.length/this.layerRepeat)*this.layerRepeat};e.children.push(r),this.currentDepth=r.depth,this.node=r}append(e){this.node.data=e}reduce(e){return this._reduce(this.root,e)}async _reduce(e,r){let n=[];return e.children.length&&(n=await Promise.all(e.children.filter(i=>i.data).map(i=>this._reduce(i,r)))),r((e.data||[]).concat(n))}_findParent(e,r){const n=e.parent;if(!(!n||n.depth===0))return n.children.length===n.maxChildren||!n.maxChildren?this._findParent(n,r):n}}class Root extends SubTree{constructor(e){super(0,e),this.root.depth=0,this.currentDepth=1}addChild(e){this.root.children.push(e)}reduce(e){return e((this.root.data||[]).concat(this.root.children))}}async function*bufferImporter(t,e,r){for await(let n of t.content)yield async()=>{r.progress(n.length,t.path);let i;const o={codec:dagPb,cidVersion:r.cidVersion,hasher:r.hasher,onlyHash:r.onlyHash};return r.rawLeaves?(o.codec=raw,o.cidVersion=1):(i=new UnixFS({type:r.leafType,data:n}),n=encode$1({Data:i.marshal(),Links:[]})),{cid:await persist(n,e,o),unixfs:i,size:n.length}}}const dagBuilders={flat,balanced,trickle:trickleStream};async function*buildFileBatch(t,e,r){let n=-1,i,o;typeof r.bufferImporter=="function"?o=r.bufferImporter:o=bufferImporter;for await(const s of parallelBatch$1(o(t,e,r),r.blockWriteConcurrency)){if(n++,n===0){i=s;continue}else n===1&&i&&(yield i,i=null);yield s}i&&(i.single=!0,yield i)}const reduce=(t,e,r)=>{async function n(i){if(i.length===1&&i[0].single&&r.reduceSingleLeafToSelf){const l=i[0];if(t.mtime!==void 0||t.mode!==void 0){let m=await e.get(l.cid);l.unixfs=new UnixFS({type:"file",mtime:t.mtime,mode:t.mode,data:m}),m=encode$1(prepare({Data:l.unixfs.marshal()})),l.cid=await persist(m,e,{...r,codec:dagPb,hasher:r.hasher,cidVersion:r.cidVersion}),l.size=m.length}return{cid:l.cid,path:t.path,unixfs:l.unixfs,size:l.size}}const o=new UnixFS({type:"file",mtime:t.mtime,mode:t.mode}),s=i.filter(l=>l.cid.code===code$2&&l.size||l.unixfs&&!l.unixfs.data&&l.unixfs.fileSize()?!0:!!(l.unixfs&&l.unixfs.data&&l.unixfs.data.length)).map(l=>l.cid.code===code$2?(o.addBlockSize(l.size),{Name:"",Tsize:l.size,Hash:l.cid}):(!l.unixfs||!l.unixfs.data?o.addBlockSize(l.unixfs&&l.unixfs.fileSize()||0):o.addBlockSize(l.unixfs.data.length),{Name:"",Tsize:l.size,Hash:l.cid})),a={Data:o.marshal(),Links:s},c=encode$1(prepare(a));return{cid:await persist(c,e,r),path:t.path,unixfs:o,size:c.length+a.Links.reduce((l,m)=>l+m.Tsize,0)}}return n};function fileBuilder(t,e,r){const n=dagBuilders[r.strategy];if(!n)throw errCode$1(new Error(`Unknown importer build strategy name: ${r.strategy}`),"ERR_BAD_STRATEGY");return n(buildFileBatch(t,e,r),reduce(t,e,r),r)}const{Buffer}=buffer$1,symbol=Symbol.for("BufferList");function BufferList(t){if(!(this instanceof BufferList))return new BufferList(t);BufferList._init.call(this,t)}BufferList._init=function t(e){Object.defineProperty(this,symbol,{value:!0}),this._bufs=[],this.length=0,e&&this.append(e)};BufferList.prototype._new=function t(e){return new BufferList(e)};BufferList.prototype._offset=function t(e){if(e===0)return[0,0];let r=0;for(let n=0;n<this._bufs.length;n++){const i=r+this._bufs[n].length;if(e<i||n===this._bufs.length-1)return[n,e-r];r=i}};BufferList.prototype._reverseOffset=function(t){const e=t[0];let r=t[1];for(let n=0;n<e;n++)r+=this._bufs[n].length;return r};BufferList.prototype.get=function t(e){if(e>this.length||e<0)return;const r=this._offset(e);return this._bufs[r[0]][r[1]]};BufferList.prototype.slice=function t(e,r){return typeof e=="number"&&e<0&&(e+=this.length),typeof r=="number"&&r<0&&(r+=this.length),this.copy(null,0,e,r)};BufferList.prototype.copy=function t(e,r,n,i){if((typeof n!="number"||n<0)&&(n=0),(typeof i!="number"||i>this.length)&&(i=this.length),n>=this.length||i<=0)return e||Buffer.alloc(0);const o=!!e,s=this._offset(n),a=i-n;let c=a,f=o&&r||0,l=s[1];if(n===0&&i===this.length){if(!o)return this._bufs.length===1?this._bufs[0]:Buffer.concat(this._bufs,this.length);for(let m=0;m<this._bufs.length;m++)this._bufs[m].copy(e,f),f+=this._bufs[m].length;return e}if(c<=this._bufs[s[0]].length-l)return o?this._bufs[s[0]].copy(e,r,l,l+c):this._bufs[s[0]].slice(l,l+c);o||(e=Buffer.allocUnsafe(a));for(let m=s[0];m<this._bufs.length;m++){const y=this._bufs[m].length-l;if(c>y)this._bufs[m].copy(e,f,l),f+=y;else{this._bufs[m].copy(e,f,l,l+c),f+=y;break}c-=y,l&&(l=0)}return e.length>f?e.slice(0,f):e};BufferList.prototype.shallowSlice=function t(e,r){if(e=e||0,r=typeof r!="number"?this.length:r,e<0&&(e+=this.length),r<0&&(r+=this.length),e===r)return this._new();const n=this._offset(e),i=this._offset(r),o=this._bufs.slice(n[0],i[0]+1);return i[1]===0?o.pop():o[o.length-1]=o[o.length-1].slice(0,i[1]),n[1]!==0&&(o[0]=o[0].slice(n[1])),this._new(o)};BufferList.prototype.toString=function t(e,r,n){return this.slice(r,n).toString(e)};BufferList.prototype.consume=function t(e){if(e=Math.trunc(e),Number.isNaN(e)||e<=0)return this;for(;this._bufs.length;)if(e>=this._bufs[0].length)e-=this._bufs[0].length,this.length-=this._bufs[0].length,this._bufs.shift();else{this._bufs[0]=this._bufs[0].slice(e),this.length-=e;break}return this};BufferList.prototype.duplicate=function t(){const e=this._new();for(let r=0;r<this._bufs.length;r++)e.append(this._bufs[r]);return e};BufferList.prototype.append=function t(e){if(e==null)return this;if(e.buffer)this._appendBuffer(Buffer.from(e.buffer,e.byteOffset,e.byteLength));else if(Array.isArray(e))for(let r=0;r<e.length;r++)this.append(e[r]);else if(this._isBufferList(e))for(let r=0;r<e._bufs.length;r++)this.append(e._bufs[r]);else typeof e=="number"&&(e=e.toString()),this._appendBuffer(Buffer.from(e));return this};BufferList.prototype._appendBuffer=function t(e){this._bufs.push(e),this.length+=e.length};BufferList.prototype.indexOf=function(t,e,r){if(r===void 0&&typeof e=="string"&&(r=e,e=void 0),typeof t=="function"||Array.isArray(t))throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');if(typeof t=="number"?t=Buffer.from([t]):typeof t=="string"?t=Buffer.from(t,r):this._isBufferList(t)?t=t.slice():Array.isArray(t.buffer)?t=Buffer.from(t.buffer,t.byteOffset,t.byteLength):Buffer.isBuffer(t)||(t=Buffer.from(t)),e=Number(e||0),isNaN(e)&&(e=0),e<0&&(e=this.length+e),e<0&&(e=0),t.length===0)return e>this.length?this.length:e;const n=this._offset(e);let i=n[0],o=n[1];for(;i<this._bufs.length;i++){const s=this._bufs[i];for(;o<s.length;)if(s.length-o>=t.length){const c=s.indexOf(t,o);if(c!==-1)return this._reverseOffset([i,c]);o=s.length-t.length+1}else{const c=this._reverseOffset([i,o]);if(this._match(c,t))return c;o++}o=0}return-1};BufferList.prototype._match=function(t,e){if(this.length-t<e.length)return!1;for(let r=0;r<e.length;r++)if(this.get(t+r)!==e[r])return!1;return!0};(function(){const t={readDoubleBE:8,readDoubleLE:8,readFloatBE:4,readFloatLE:4,readInt32BE:4,readInt32LE:4,readUInt32BE:4,readUInt32LE:4,readInt16BE:2,readInt16LE:2,readUInt16BE:2,readUInt16LE:2,readInt8:1,readUInt8:1,readIntBE:null,readIntLE:null,readUIntBE:null,readUIntLE:null};for(const e in t)(function(r){t[r]===null?BufferList.prototype[r]=function(n,i){return this.slice(n,n+i)[r](0,i)}:BufferList.prototype[r]=function(n=0){return this.slice(n,n+t[r])[r](0)}})(e)})();BufferList.prototype._isBufferList=function t(e){return e instanceof BufferList||BufferList.isBufferList(e)};BufferList.isBufferList=function t(e){return e!=null&&e[symbol]};var BufferList_1=BufferList;const BufferList$1=getDefaultExportFromCjs(BufferList_1);let Rabin$1=class{constructor(e,r=12,n=8*1024,i=32*1024,o=64,s){this.bits=r,this.min=n,this.max=i,this.asModule=e,this.rabin=new e.Rabin(r,n,i,o,s),this.polynomial=s}fingerprint(e){const{__retain:r,__release:n,__allocArray:i,__getInt32Array:o,Int32Array_ID:s,Uint8Array_ID:a}=this.asModule,c=new Int32Array(Math.ceil(e.length/this.min)),f=r(i(s,c)),l=r(i(a,e)),m=this.rabin.fingerprint(l,f),y=o(m);n(l),n(f);const h=y.indexOf(0);return h>=0?y.subarray(0,h):y}};var rabin$1=Rabin$1,loader={};const ID_OFFSET=-8,SIZE_OFFSET=-4,ARRAYBUFFER_ID=0,STRING_ID=1,ARRAYBUFFERVIEW=1,ARRAY=2,VAL_ALIGN_OFFSET=5,VAL_SIGNED=1024,VAL_FLOAT=2048,VAL_MANAGED=8192,ARRAYBUFFERVIEW_BUFFER_OFFSET=0,ARRAYBUFFERVIEW_DATASTART_OFFSET=4,ARRAYBUFFERVIEW_DATALENGTH_OFFSET=8,ARRAYBUFFERVIEW_SIZE=12,ARRAY_LENGTH_OFFSET=12,ARRAY_SIZE=16,BIGINT=typeof BigUint64Array<"u",THIS=Symbol(),CHUNKSIZE=1024;function getStringImpl(t,e){const r=new Uint32Array(t),n=new Uint16Array(t);var i=r[e+SIZE_OFFSET>>>2]>>>1,o=e>>>1;if(i<=CHUNKSIZE)return String.fromCharCode.apply(String,n.subarray(o,o+i));const s=[];do{const a=n[o+CHUNKSIZE-1],c=a>=55296&&a<56320?CHUNKSIZE-1:CHUNKSIZE;s.push(String.fromCharCode.apply(String,n.subarray(o,o+=c))),i-=c}while(i>CHUNKSIZE);return s.join("")+String.fromCharCode.apply(String,n.subarray(o,o+i))}function preInstantiate(t){const e={};function r(i,o){return i?getStringImpl(i.buffer,o):"<yet unknown>"}const n=t.env=t.env||{};return n.abort=n.abort||function(o,s,a,c){const f=e.memory||n.memory;throw Error("abort: "+r(f,o)+" at "+r(f,s)+":"+a+":"+c)},n.trace=n.trace||function(o,s){const a=e.memory||n.memory;console.log("trace: "+r(a,o)+(s?" ":"")+Array.prototype.slice.call(arguments,2,2+s).join(", "))},t.Math=t.Math||Math,t.Date=t.Date||Date,e}function postInstantiate(t,e){const r=e.exports,n=r.memory,i=r.table,o=r.__alloc,s=r.__retain,a=r.__rtti_base||-1;function c(g){const w=new Uint32Array(n.buffer),_=w[a>>>2];if((g>>>=0)>=_)throw Error("invalid id: "+g);return w[(a+4>>>2)+g*2]}function f(g){const w=new Uint32Array(n.buffer),_=w[a>>>2];if((g>>>=0)>=_)throw Error("invalid id: "+g);return w[(a+4>>>2)+g*2+1]}function l(g){return 31-Math.clz32(g>>>VAL_ALIGN_OFFSET&31)}function m(g){const w=g.length,_=o(w<<1,STRING_ID),$=new Uint16Array(n.buffer);for(var E=0,k=_>>>1;E<w;++E)$[k+E]=g.charCodeAt(E);return _}t.__allocString=m;function y(g){const w=n.buffer;if(new Uint32Array(w)[g+ID_OFFSET>>>2]!==STRING_ID)throw Error("not a string: "+g);return getStringImpl(w,g)}t.__getString=y;function h(g,w,_){const $=n.buffer;if(_)switch(g){case 2:return new Float32Array($);case 3:return new Float64Array($)}else switch(g){case 0:return new(w?Int8Array:Uint8Array)($);case 1:return new(w?Int16Array:Uint16Array)($);case 2:return new(w?Int32Array:Uint32Array)($);case 3:return new(w?BigInt64Array:BigUint64Array)($)}throw Error("unsupported align: "+g)}function d(g,w){const _=c(g);if(!(_&(ARRAYBUFFERVIEW|ARRAY)))throw Error("not an array: "+g+" @ "+_);const $=l(_),E=w.length,k=o(E<<$,ARRAYBUFFER_ID),S=o(_&ARRAY?ARRAY_SIZE:ARRAYBUFFERVIEW_SIZE,g),v=new Uint32Array(n.buffer);v[S+ARRAYBUFFERVIEW_BUFFER_OFFSET>>>2]=s(k),v[S+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2]=k,v[S+ARRAYBUFFERVIEW_DATALENGTH_OFFSET>>>2]=E<<$,_&ARRAY&&(v[S+ARRAY_LENGTH_OFFSET>>>2]=E);const x=h($,_&VAL_SIGNED,_&VAL_FLOAT);if(_&VAL_MANAGED)for(let C=0;C<E;++C)x[(k>>>$)+C]=s(w[C]);else x.set(w,k>>>$);return S}t.__allocArray=d;function u(g){const w=new Uint32Array(n.buffer),_=w[g+ID_OFFSET>>>2],$=c(_);if(!($&ARRAYBUFFERVIEW))throw Error("not an array: "+_);const E=l($);var k=w[g+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];const S=$&ARRAY?w[g+ARRAY_LENGTH_OFFSET>>>2]:w[k+SIZE_OFFSET>>>2]>>>E;return h(E,$&VAL_SIGNED,$&VAL_FLOAT).subarray(k>>>=E,k+S)}t.__getArrayView=u;function p(g){const w=u(g),_=w.length,$=new Array(_);for(let E=0;E<_;E++)$[E]=w[E];return $}t.__getArray=p;function b(g){const w=n.buffer,_=new Uint32Array(w)[g+SIZE_OFFSET>>>2];return w.slice(g,g+_)}t.__getArrayBuffer=b;function A(g,w,_){return new g(D(g,w,_))}function D(g,w,_){const $=n.buffer,E=new Uint32Array($),k=E[_+ARRAYBUFFERVIEW_DATASTART_OFFSET>>>2];return new g($,k,E[k+SIZE_OFFSET>>>2]>>>w)}t.__getInt8Array=A.bind(null,Int8Array,0),t.__getInt8ArrayView=D.bind(null,Int8Array,0),t.__getUint8Array=A.bind(null,Uint8Array,0),t.__getUint8ArrayView=D.bind(null,Uint8Array,0),t.__getUint8ClampedArray=A.bind(null,Uint8ClampedArray,0),t.__getUint8ClampedArrayView=D.bind(null,Uint8ClampedArray,0),t.__getInt16Array=A.bind(null,Int16Array,1),t.__getInt16ArrayView=D.bind(null,Int16Array,1),t.__getUint16Array=A.bind(null,Uint16Array,1),t.__getUint16ArrayView=D.bind(null,Uint16Array,1),t.__getInt32Array=A.bind(null,Int32Array,2),t.__getInt32ArrayView=D.bind(null,Int32Array,2),t.__getUint32Array=A.bind(null,Uint32Array,2),t.__getUint32ArrayView=D.bind(null,Uint32Array,2),BIGINT&&(t.__getInt64Array=A.bind(null,BigInt64Array,3),t.__getInt64ArrayView=D.bind(null,BigInt64Array,3),t.__getUint64Array=A.bind(null,BigUint64Array,3),t.__getUint64ArrayView=D.bind(null,BigUint64Array,3)),t.__getFloat32Array=A.bind(null,Float32Array,2),t.__getFloat32ArrayView=D.bind(null,Float32Array,2),t.__getFloat64Array=A.bind(null,Float64Array,3),t.__getFloat64ArrayView=D.bind(null,Float64Array,3);function T(g,w){const _=new Uint32Array(n.buffer);var $=_[g+ID_OFFSET>>>2];if($<=_[a>>>2])do if($==w)return!0;while($=f($));return!1}return t.__instanceof=T,t.memory=t.memory||n,t.table=t.table||i,demangle(r,t)}function isResponse(t){return typeof Response<"u"&&t instanceof Response}async function instantiate$1(t,e){return isResponse(t=await t)?instantiateStreaming(t,e):postInstantiate(preInstantiate(e||(e={})),await WebAssembly.instantiate(t instanceof WebAssembly.Module?t:await WebAssembly.compile(t),e))}loader.instantiate=instantiate$1;function instantiateSync(t,e){return postInstantiate(preInstantiate(e||(e={})),new WebAssembly.Instance(t instanceof WebAssembly.Module?t:new WebAssembly.Module(t),e))}loader.instantiateSync=instantiateSync;async function instantiateStreaming(t,e){return WebAssembly.instantiateStreaming?postInstantiate(preInstantiate(e||(e={})),(await WebAssembly.instantiateStreaming(t,e)).instance):instantiate$1(isResponse(t=await t)?t.arrayBuffer():t,e)}loader.instantiateStreaming=instantiateStreaming;function demangle(t,e){var r=e?Object.create(e):{},n=t.__argumentsLength?function(i){t.__argumentsLength.value=i}:t.__setArgumentsLength||t.__setargc||function(){};for(let i in t){if(!Object.prototype.hasOwnProperty.call(t,i))continue;const o=t[i];let s=i.split("."),a=r;for(;s.length>1;){let l=s.shift();Object.prototype.hasOwnProperty.call(a,l)||(a[l]={}),a=a[l]}let c=s[0],f=c.indexOf("#");if(f>=0){let l=c.substring(0,f),m=a[l];if(typeof m>"u"||!m.prototype){let y=function(...h){return y.wrap(y.prototype.constructor(0,...h))};y.prototype={valueOf:function(){return this[THIS]}},y.wrap=function(h){return Object.create(y.prototype,{[THIS]:{value:h,writable:!1}})},m&&Object.getOwnPropertyNames(m).forEach(h=>Object.defineProperty(y,h,Object.getOwnPropertyDescriptor(m,h))),a[l]=y}if(c=c.substring(f+1),a=a[l].prototype,/^(get|set):/.test(c)){if(!Object.prototype.hasOwnProperty.call(a,c=c.substring(4))){let y=t[i.replace("set:","get:")],h=t[i.replace("get:","set:")];Object.defineProperty(a,c,{get:function(){return y(this[THIS])},set:function(d){h(this[THIS],d)},enumerable:!0})}}else c==="constructor"?(a[c]=(...y)=>(n(y.length),o(...y))).original=o:(a[c]=function(...y){return n(y.length),o(this[THIS],...y)}).original=o}else/^(get|set):/.test(c)?Object.prototype.hasOwnProperty.call(a,c=c.substring(4))||Object.defineProperty(a,c,{get:t[i.replace("set:","get:")],set:t[i.replace("get:","set:")],enumerable:!0}):typeof o=="function"&&o!==n?(a[c]=(...l)=>(n(l.length),o(...l))).original=o:a[c]=o}return r}loader.demangle=demangle;const{instantiate}=loader;loadWebAssembly.supported=typeof WebAssembly<"u";function loadWebAssembly(t={}){if(!loadWebAssembly.supported)return null;var e=new Uint8Array([0,97,115,109,1,0,0,0,1,78,14,96,2,127,126,0,96,1,127,1,126,96,2,127,127,0,96,1,127,1,127,96,1,127,0,96,2,127,127,1,127,96,3,127,127,127,1,127,96,0,0,96,3,127,127,127,0,96,0,1,127,96,4,127,127,127,127,0,96,5,127,127,127,127,127,1,127,96,1,126,1,127,96,2,126,126,1,126,2,13,1,3,101,110,118,5,97,98,111,114,116,0,10,3,54,53,2,2,8,9,3,5,2,8,6,5,3,4,2,6,9,12,13,2,5,11,3,2,3,2,3,2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,6,7,7,4,4,5,3,1,0,1,6,47,9,127,1,65,0,11,127,1,65,0,11,127,0,65,3,11,127,0,65,4,11,127,1,65,0,11,127,1,65,0,11,127,1,65,0,11,127,0,65,240,2,11,127,0,65,6,11,7,240,5,41,6,109,101,109,111,114,121,2,0,7,95,95,97,108,108,111,99,0,10,8,95,95,114,101,116,97,105,110,0,11,9,95,95,114,101,108,101,97,115,101,0,12,9,95,95,99,111,108,108,101,99,116,0,51,11,95,95,114,116,116,105,95,98,97,115,101,3,7,13,73,110,116,51,50,65,114,114,97,121,95,73,68,3,2,13,85,105,110,116,56,65,114,114,97,121,95,73,68,3,3,6,100,101,103,114,101,101,0,16,3,109,111,100,0,17,5,82,97,98,105,110,3,8,16,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,0,21,16,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,0,22,21,82,97,98,105,110,35,103,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,23,21,82,97,98,105,110,35,115,101,116,58,119,105,110,100,111,119,95,115,105,122,101,0,24,14,82,97,98,105,110,35,103,101,116,58,119,112,111,115,0,25,14,82,97,98,105,110,35,115,101,116,58,119,112,111,115,0,26,15,82,97,98,105,110,35,103,101,116,58,99,111,117,110,116,0,27,15,82,97,98,105,110,35,115,101,116,58,99,111,117,110,116,0,28,13,82,97,98,105,110,35,103,101,116,58,112,111,115,0,29,13,82,97,98,105,110,35,115,101,116,58,112,111,115,0,30,15,82,97,98,105,110,35,103,101,116,58,115,116,97,114,116,0,31,15,82,97,98,105,110,35,115,101,116,58,115,116,97,114,116,0,32,16,82,97,98,105,110,35,103,101,116,58,100,105,103,101,115,116,0,33,16,82,97,98,105,110,35,115,101,116,58,100,105,103,101,115,116,0,34,21,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,35,21,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,115,116,97,114,116,0,36,22,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,37,22,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,108,101,110,103,116,104,0,38,31,82,97,98,105,110,35,103,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,39,31,82,97,98,105,110,35,115,101,116,58,99,104,117,110,107,95,99,117,116,95,102,105,110,103,101,114,112,114,105,110,116,0,40,20,82,97,98,105,110,35,103,101,116,58,112,111,108,121,110,111,109,105,97,108,0,41,20,82,97,98,105,110,35,115,101,116,58,112,111,108,121,110,111,109,105,97,108,0,42,17,82,97,98,105,110,35,103,101,116,58,109,105,110,115,105,122,101,0,43,17,82,97,98,105,110,35,115,101,116,58,109,105,110,115,105,122,101,0,44,17,82,97,98,105,110,35,103,101,116,58,109,97,120,115,105,122,101,0,45,17,82,97,98,105,110,35,115,101,116,58,109,97,120,115,105,122,101,0,46,14,82,97,98,105,110,35,103,101,116,58,109,97,115,107,0,47,14,82,97,98,105,110,35,115,101,116,58,109,97,115,107,0,48,17,82,97,98,105,110,35,99,111,110,115,116,114,117,99,116,111,114,0,20,17,82,97,98,105,110,35,102,105,110,103,101,114,112,114,105,110,116,0,49,8,1,50,10,165,31,53,199,1,1,4,127,32,1,40,2,0,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,3,65,4,107,118,65,16,115,33,4,32,3,65,7,107,11,33,3,32,1,40,2,20,33,2,32,1,40,2,16,34,5,4,64,32,5,32,2,54,2,20,11,32,2,4,64,32,2,32,5,54,2,16,11,32,1,32,0,32,4,32,3,65,4,116,106,65,2,116,106,40,2,96,70,4,64,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,2,54,2,96,32,2,69,4,64,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,65,127,115,113,34,1,54,2,4,32,1,69,4,64,32,0,32,0,40,2,0,65,1,32,3,116,65,127,115,113,54,2,0,11,11,11,11,226,2,1,6,127,32,1,40,2,0,33,3,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,34,5,65,1,113,4,64,32,3,65,124,113,65,16,106,32,5,65,124,113,106,34,2,65,240,255,255,255,3,73,4,64,32,0,32,4,16,1,32,1,32,2,32,3,65,3,113,114,34,3,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,34,4,40,2,0,33,5,11,11,32,3,65,2,113,4,64,32,1,65,4,107,40,2,0,34,2,40,2,0,34,6,65,124,113,65,16,106,32,3,65,124,113,106,34,7,65,240,255,255,255,3,73,4,64,32,0,32,2,16,1,32,2,32,7,32,6,65,3,113,114,34,3,54,2,0,32,2,33,1,11,11,32,4,32,5,65,2,114,54,2,0,32,4,65,4,107,32,1,54,2,0,32,0,32,3,65,124,113,34,2,65,128,2,73,4,127,32,2,65,4,118,33,4,65,0,5,32,2,65,31,32,2,103,107,34,2,65,4,107,118,65,16,115,33,4,32,2,65,7,107,11,34,3,65,4,116,32,4,106,65,2,116,106,40,2,96,33,2,32,1,65,0,54,2,16,32,1,32,2,54,2,20,32,2,4,64,32,2,32,1,54,2,16,11,32,0,32,4,32,3,65,4,116,106,65,2,116,106,32,1,54,2,96,32,0,32,0,40,2,0,65,1,32,3,116,114,54,2,0,32,0,32,3,65,2,116,106,32,0,32,3,65,2,116,106,40,2,4,65,1,32,4,116,114,54,2,4,11,119,1,1,127,32,2,2,127,32,0,40,2,160,12,34,2,4,64,32,2,32,1,65,16,107,70,4,64,32,2,40,2,0,33,3,32,1,65,16,107,33,1,11,11,32,1,11,107,34,2,65,48,73,4,64,15,11,32,1,32,3,65,2,113,32,2,65,32,107,65,1,114,114,54,2,0,32,1,65,0,54,2,16,32,1,65,0,54,2,20,32,1,32,2,106,65,16,107,34,2,65,2,54,2,0,32,0,32,2,54,2,160,12,32,0,32,1,16,2,11,155,1,1,3,127,35,0,34,0,69,4,64,65,1,63,0,34,0,74,4,127,65,1,32,0,107,64,0,65,0,72,5,65,0,11,4,64,0,11,65,176,3,34,0,65,0,54,2,0,65,208,15,65,0,54,2,0,3,64,32,1,65,23,73,4,64,32,1,65,2,116,65,176,3,106,65,0,54,2,4,65,0,33,2,3,64,32,2,65,16,73,4,64,32,1,65,4,116,32,2,106,65,2,116,65,176,3,106,65,0,54,2,96,32,2,65,1,106,33,2,12,1,11,11,32,1,65,1,106,33,1,12,1,11,11,65,176,3,65,224,15,63,0,65,16,116,16,3,65,176,3,36,0,11,32,0,11,45,0,32,0,65,240,255,255,255,3,79,4,64,65,32,65,224,0,65,201,3,65,29,16,0,0,11,32,0,65,15,106,65,112,113,34,0,65,16,32,0,65,16,75,27,11,169,1,1,1,127,32,0,32,1,65,128,2,73,4,127,32,1,65,4,118,33,1,65,0,5,32,1,65,248,255,255,255,1,73,4,64,32,1,65,1,65,27,32,1,103,107,116,106,65,1,107,33,1,11,32,1,65,31,32,1,103,107,34,2,65,4,107,118,65,16,115,33,1,32,2,65,7,107,11,34,2,65,2,116,106,40,2,4,65,127,32,1,116,113,34,1,4,127,32,0,32,1,104,32,2,65,4,116,106,65,2,116,106,40,2,96,5,32,0,40,2,0,65,127,32,2,65,1,106,116,113,34,1,4,127,32,0,32,0,32,1,104,34,0,65,2,116,106,40,2,4,104,32,0,65,4,116,106,65,2,116,106,40,2,96,5,65,0,11,11,11,111,1,1,127,63,0,34,2,32,1,65,248,255,255,255,1,73,4,127,32,1,65,1,65,27,32,1,103,107,116,65,1,107,106,5,32,1,11,65,16,32,0,40,2,160,12,32,2,65,16,116,65,16,107,71,116,106,65,255,255,3,106,65,128,128,124,113,65,16,118,34,1,32,2,32,1,74,27,64,0,65,0,72,4,64,32,1,64,0,65,0,72,4,64,0,11,11,32,0,32,2,65,16,116,63,0,65,16,116,16,3,11,113,1,2,127,32,1,40,2,0,34,3,65,124,113,32,2,107,34,4,65,32,79,4,64,32,1,32,2,32,3,65,2,113,114,54,2,0,32,2,32,1,65,16,106,106,34,1,32,4,65,16,107,65,1,114,54,2,0,32,0,32,1,16,2,5,32,1,32,3,65,126,113,54,2,0,32,1,65,16,106,32,1,40,2,0,65,124,113,106,32,1,65,16,106,32,1,40,2,0,65,124,113,106,40,2,0,65,125,113,54,2,0,11,11,91,1,2,127,32,0,32,1,16,5,34,4,16,6,34,3,69,4,64,65,1,36,1,65,0,36,1,32,0,32,4,16,6,34,3,69,4,64,32,0,32,4,16,7,32,0,32,4,16,6,33,3,11,11,32,3,65,0,54,2,4,32,3,32,2,54,2,8,32,3,32,1,54,2,12,32,0,32,3,16,1,32,0,32,3,32,4,16,8,32,3,11,13,0,16,4,32,0,32,1,16,9,65,16,106,11,33,1,1,127,32,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,18,0,32,0,65,172,3,75,4,64,32,0,65,16,107,16,52,11,11,140,3,1,1,127,2,64,32,1,69,13,0,32,0,65,0,58,0,0,32,0,32,1,106,65,1,107,65,0,58,0,0,32,1,65,2,77,13,0,32,0,65,1,106,65,0,58,0,0,32,0,65,2,106,65,0,58,0,0,32,0,32,1,106,34,2,65,2,107,65,0,58,0,0,32,2,65,3,107,65,0,58,0,0,32,1,65,6,77,13,0,32,0,65,3,106,65,0,58,0,0,32,0,32,1,106,65,4,107,65,0,58,0,0,32,1,65,8,77,13,0,32,1,65,0,32,0,107,65,3,113,34,1,107,33,2,32,0,32,1,106,34,0,65,0,54,2,0,32,0,32,2,65,124,113,34,1,106,65,4,107,65,0,54,2,0,32,1,65,8,77,13,0,32,0,65,4,106,65,0,54,2,0,32,0,65,8,106,65,0,54,2,0,32,0,32,1,106,34,2,65,12,107,65,0,54,2,0,32,2,65,8,107,65,0,54,2,0,32,1,65,24,77,13,0,32,0,65,12,106,65,0,54,2,0,32,0,65,16,106,65,0,54,2,0,32,0,65,20,106,65,0,54,2,0,32,0,65,24,106,65,0,54,2,0,32,0,32,1,106,34,2,65,28,107,65,0,54,2,0,32,2,65,24,107,65,0,54,2,0,32,2,65,20,107,65,0,54,2,0,32,2,65,16,107,65,0,54,2,0,32,0,32,0,65,4,113,65,24,106,34,2,106,33,0,32,1,32,2,107,33,1,3,64,32,1,65,32,79,4,64,32,0,66,0,55,3,0,32,0,65,8,106,66,0,55,3,0,32,0,65,16,106,66,0,55,3,0,32,0,65,24,106,66,0,55,3,0,32,1,65,32,107,33,1,32,0,65,32,106,33,0,12,1,11,11,11,11,178,1,1,3,127,32,1,65,240,255,255,255,3,32,2,118,75,4,64,65,144,1,65,192,1,65,23,65,56,16,0,0,11,32,1,32,2,116,34,3,65,0,16,10,34,2,32,3,16,13,32,0,69,4,64,65,12,65,2,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,2,34,1,32,0,40,2,0,34,4,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,32,4,16,12,11,32,0,32,1,54,2,0,32,0,32,2,54,2,4,32,0,32,3,54,2,8,32,0,11,46,1,2,127,65,12,65,5,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,65,128,2,65,3,16,14,11,9,0,65,63,32,0,121,167,107,11,49,1,2,127,65,63,32,1,121,167,107,33,2,3,64,65,63,32,0,121,167,107,32,2,107,34,3,65,0,78,4,64,32,0,32,1,32,3,172,134,133,33,0,12,1,11,11,32,0,11,40,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,163,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,65,0,58,0,0,11,38,0,32,1,32,0,40,2,8,79,4,64,65,128,2,65,192,2,65,152,1,65,44,16,0,0,11,32,1,32,0,40,2,4,106,45,0,0,11,254,5,2,1,127,4,126,32,0,69,4,64,65,232,0,65,6,16,10,34,0,65,172,3,75,4,64,32,0,65,16,107,34,5,32,5,40,2,4,65,1,106,54,2,4,11,11,32,0,65,0,54,2,0,32,0,65,0,54,2,4,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,24,32,0,66,0,55,3,32,32,0,66,0,55,3,40,32,0,66,0,55,3,48,32,0,66,0,55,3,56,32,0,66,0,55,3,64,32,0,66,0,55,3,72,32,0,66,0,55,3,80,32,0,66,0,55,3,88,32,0,66,0,55,3,96,32,0,32,2,173,55,3,80,32,0,32,3,173,55,3,88,65,12,65,4,16,10,34,2,65,172,3,75,4,64,32,2,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,32,4,65,0,16,14,33,2,32,0,40,2,0,16,12,32,0,32,2,54,2,0,32,0,32,4,54,2,4,32,0,66,1,32,1,173,134,66,1,125,55,3,96,32,0,66,243,130,183,218,216,230,232,30,55,3,72,35,4,69,4,64,65,0,33,2,3,64,32,2,65,128,2,72,4,64,32,2,65,255,1,113,173,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,65,0,33,4,3,64,32,4,32,0,40,2,4,65,1,107,72,4,64,32,6,66,8,134,33,6,32,0,41,3,72,34,7,33,8,65,63,32,7,121,167,107,33,1,3,64,65,63,32,6,121,167,107,32,1,107,34,3,65,0,78,4,64,32,6,32,8,32,3,172,134,133,33,6,12,1,11,11,32,4,65,1,106,33,4,12,1,11,11,35,6,40,2,4,32,2,65,3,116,106,32,6,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,63,32,0,41,3,72,121,167,107,172,33,7,65,0,33,2,3,64,32,2,65,128,2,72,4,64,35,5,33,1,32,2,172,32,7,134,34,8,33,6,65,63,32,0,41,3,72,34,9,121,167,107,33,3,3,64,65,63,32,6,121,167,107,32,3,107,34,4,65,0,78,4,64,32,6,32,9,32,4,172,134,133,33,6,12,1,11,11,32,1,40,2,4,32,2,65,3,116,106,32,6,32,8,132,55,3,0,32,2,65,1,106,33,2,12,1,11,11,65,1,36,4,11,32,0,66,0,55,3,24,32,0,66,0,55,3,32,65,0,33,2,3,64,32,2,32,0,40,2,4,72,4,64,32,0,40,2,0,32,2,16,18,32,2,65,1,106,33,2,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,6,66,45,136,167,65,3,116,106,41,3,0,32,6,66,8,134,66,1,132,133,55,3,40,32,0,11,38,1,1,127,32,0,40,2,0,34,0,65,172,3,75,4,64,32,0,65,16,107,34,1,32,1,40,2,4,65,1,106,54,2,4,11,32,0,11,55,1,2,127,32,1,32,0,40,2,0,34,2,71,4,64,32,1,65,172,3,75,4,64,32,1,65,16,107,34,3,32,3,40,2,4,65,1,106,54,2,4,11,32,2,16,12,11,32,0,32,1,54,2,0,11,7,0,32,0,40,2,4,11,9,0,32,0,32,1,54,2,4,11,7,0,32,0,40,2,8,11,9,0,32,0,32,1,54,2,8,11,7,0,32,0,41,3,16,11,9,0,32,0,32,1,55,3,16,11,7,0,32,0,41,3,24,11,9,0,32,0,32,1,55,3,24,11,7,0,32,0,41,3,32,11,9,0,32,0,32,1,55,3,32,11,7,0,32,0,41,3,40,11,9,0,32,0,32,1,55,3,40,11,7,0,32,0,41,3,48,11,9,0,32,0,32,1,55,3,48,11,7,0,32,0,41,3,56,11,9,0,32,0,32,1,55,3,56,11,7,0,32,0,41,3,64,11,9,0,32,0,32,1,55,3,64,11,7,0,32,0,41,3,72,11,9,0,32,0,32,1,55,3,72,11,7,0,32,0,41,3,80,11,9,0,32,0,32,1,55,3,80,11,7,0,32,0,41,3,88,11,9,0,32,0,32,1,55,3,88,11,7,0,32,0,41,3,96,11,9,0,32,0,32,1,55,3,96,11,172,4,2,5,127,1,126,32,2,65,172,3,75,4,64,32,2,65,16,107,34,4,32,4,40,2,4,65,1,106,54,2,4,11,32,2,33,4,65,0,33,2,32,1,40,2,8,33,5,32,1,40,2,4,33,6,3,64,2,127,65,0,33,3,3,64,32,3,32,5,72,4,64,32,3,32,6,106,45,0,0,33,1,32,0,40,2,0,32,0,40,2,8,16,19,33,7,32,0,40,2,8,32,0,40,2,0,40,2,4,106,32,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,7,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,1,173,32,8,66,8,134,132,133,55,3,40,32,0,32,0,41,3,16,66,1,124,55,3,16,32,0,32,0,41,3,24,66,1,124,55,3,24,32,0,41,3,16,32,0,41,3,80,90,4,127,32,0,41,3,40,32,0,41,3,96,131,80,5,65,0,11,4,127,65,1,5,32,0,41,3,16,32,0,41,3,88,90,11,4,64,32,0,32,0,41,3,32,55,3,48,32,0,32,0,41,3,16,55,3,56,32,0,32,0,41,3,40,55,3,64,65,0,33,1,3,64,32,1,32,0,40,2,4,72,4,64,32,0,40,2,0,32,1,16,18,32,1,65,1,106,33,1,12,1,11,11,32,0,66,0,55,3,40,32,0,65,0,54,2,8,32,0,66,0,55,3,16,32,0,66,0,55,3,40,32,0,40,2,0,32,0,40,2,8,16,19,33,1,32,0,40,2,8,32,0,40,2,0,40,2,4,106,65,1,58,0,0,32,0,32,0,41,3,40,35,6,40,2,4,32,1,65,3,116,106,41,3,0,133,55,3,40,32,0,32,0,40,2,8,65,1,106,32,0,40,2,4,111,54,2,8,32,0,35,5,40,2,4,32,0,41,3,40,34,8,66,45,136,167,65,3,116,106,41,3,0,32,8,66,8,134,66,1,132,133,55,3,40,32,3,65,1,106,12,3,11,32,3,65,1,106,33,3,12,1,11,11,65,127,11,34,1,65,0,78,4,64,32,5,32,1,107,33,5,32,1,32,6,106,33,6,32,2,34,1,65,1,106,33,2,32,4,40,2,4,32,1,65,2,116,106,32,0,41,3,56,62,2,0,12,1,11,11,32,4,11,10,0,16,15,36,5,16,15,36,6,11,3,0,1,11,73,1,2,127,32,0,40,2,4,34,1,65,255,255,255,255,0,113,34,2,65,1,70,4,64,32,0,65,16,106,16,53,32,0,32,0,40,2,0,65,1,114,54,2,0,35,0,32,0,16,2,5,32,0,32,2,65,1,107,32,1,65,128,128,128,128,127,113,114,54,2,4,11,11,58,0,2,64,2,64,2,64,32,0,65,8,107,40,2,0,14,7,0,0,1,1,1,1,1,2,11,15,11,32,0,40,2,0,34,0,4,64,32,0,65,172,3,79,4,64,32,0,65,16,107,16,52,11,11,15,11,0,11,11,137,3,7,0,65,16,11,55,40,0,0,0,1,0,0,0,1,0,0,0,40,0,0,0,97,0,108,0,108,0,111,0,99,0,97,0,116,0,105,0,111,0,110,0,32,0,116,0,111,0,111,0,32,0,108,0,97,0,114,0,103,0,101,0,65,208,0,11,45,30,0,0,0,1,0,0,0,1,0,0,0,30,0,0,0,126,0,108,0,105,0,98,0,47,0,114,0,116,0,47,0,116,0,108,0,115,0,102,0,46,0,116,0,115,0,65,128,1,11,43,28,0,0,0,1,0,0,0,1,0,0,0,28,0,0,0,73,0,110,0,118,0,97,0,108,0,105,0,100,0,32,0,108,0,101,0,110,0,103,0,116,0,104,0,65,176,1,11,53,38,0,0,0,1,0,0,0,1,0,0,0,38,0,0,0,126,0,108,0,105,0,98,0,47,0,97,0,114,0,114,0,97,0,121,0,98,0,117,0,102,0,102,0,101,0,114,0,46,0,116,0,115,0,65,240,1,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,73,0,110,0,100,0,101,0,120,0,32,0,111,0,117,0,116,0,32,0,111,0,102,0,32,0,114,0,97,0,110,0,103,0,101,0,65,176,2,11,51,36,0,0,0,1,0,0,0,1,0,0,0,36,0,0,0,126,0,108,0,105,0,98,0,47,0,116,0,121,0,112,0,101,0,100,0,97,0,114,0,114,0,97,0,121,0,46,0,116,0,115,0,65,240,2,11,53,7,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,145,4,0,0,2,0,0,0,49,0,0,0,2,0,0,0,17,1,0,0,2,0,0,0,16,0,34,16,115,111,117,114,99,101,77,97,112,112,105,110,103,85,82,76,16,46,47,114,97,98,105,110,46,119,97,115,109,46,109,97,112]);return instantiate(new Response(new Blob([e],{type:"application/wasm"})),t)}var rabinWasm=loadWebAssembly;const Rabin=rabin$1,getRabin=rabinWasm,create=async(t,e,r,n,i)=>{const o=await getRabin();return new Rabin(o,t,e,r,n,i)};var src$1={Rabin,create};async function*rabinChunker(t,e){let r,n,i;if(e.minChunkSize&&e.maxChunkSize&&e.avgChunkSize)i=e.avgChunkSize,r=e.minChunkSize,n=e.maxChunkSize;else if(e.avgChunkSize)i=e.avgChunkSize,r=i/3,n=i+i/2;else throw errCode$1(new Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");if(r<16)throw errCode$1(new Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");n<r&&(n=r),i<r&&(i=r);const o=Math.floor(Math.log2(i));for await(const s of rabin(t,{min:r,max:n,bits:o,window:e.window,polynomial:e.polynomial}))yield s}async function*rabin(t,e){const r=await src$1.create(e.bits,e.min,e.max,e.window),n=new BufferList$1;for await(const i of t){n.append(i);const o=r.fingerprint(i);for(let s=0;s<o.length;s++){const a=o[s],c=n.slice(0,a);n.consume(a),yield c}}n.length&&(yield n.slice(0))}async function*fixedSizeChunker(t,e){let r=new BufferList$1,n=0,i=!1;const o=e.maxChunkSize;for await(const s of t)for(r.append(s),n+=s.length;n>=o;)if(yield r.slice(0,o),i=!0,o===r.length)r=new BufferList$1,n=0;else{const a=new BufferList$1;a.append(r.shallowSlice(o)),r=a,n-=o}(!i||n)&&(yield r.slice(0,n))}const identity=from$1({prefix:"\0",name:"identity",encode:t=>toString$1(t),decode:t=>fromString$3(t)}),identityBase=Object.freeze(Object.defineProperty({__proto__:null,identity},Symbol.toStringTag,{value:"Module"})),base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$1=Object.freeze(Object.defineProperty({__proto__:null,base2},Symbol.toStringTag,{value:"Module"})),base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$1=Object.freeze(Object.defineProperty({__proto__:null,base8},Symbol.toStringTag,{value:"Module"})),base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$1=Object.freeze(Object.defineProperty({__proto__:null,base10},Symbol.toStringTag,{value:"Module"})),base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$1=Object.freeze(Object.defineProperty({__proto__:null,base16,base16upper},Symbol.toStringTag,{value:"Module"})),base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$1=Object.freeze(Object.defineProperty({__proto__:null,base36,base36upper},Symbol.toStringTag,{value:"Module"})),base64=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$1=Object.freeze(Object.defineProperty({__proto__:null,base64,base64pad,base64url,base64urlpad},Symbol.toStringTag,{value:"Module"})),alphabet=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars=alphabet.reduce((t,e,r)=>(t[r]=e,t),[]),alphabetCharsToBytes=alphabet.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function encode(t){return t.reduce((e,r)=>(e+=alphabetBytesToChars[r],e),"")}function decode(t){const e=[];for(const r of t){const n=alphabetCharsToBytes[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const base256emoji=from$1({prefix:"🚀",name:"base256emoji",encode,decode}),base256emoji$1=Object.freeze(Object.defineProperty({__proto__:null,base256emoji},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$1,...base36$1,...base58,...base64$1,...base256emoji$1};function asUint8Array(t){return globalThis.Buffer!=null?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t}function allocUnsafe(t=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?asUint8Array(globalThis.Buffer.allocUnsafe(t)):new Uint8Array(t)}function createCodec(t,e,r,n){return{name:t,prefix:e,encoder:{name:t,prefix:e,encode:r},decoder:{decode:n}}}const string=createCodec("utf8","u",t=>"u"+new TextDecoder("utf8").decode(t),t=>new TextEncoder().encode(t.substring(1))),ascii=createCodec("ascii","a",t=>{let e="a";for(let r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},t=>{t=t.substring(1);const e=allocUnsafe(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}),BASES={utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii,binary:ascii,...bases};function fromString(t,e="utf8"){const r=BASES[e];if(!r)throw new Error(`Unsupported encoding "${e}"`);return(e==="utf8"||e==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array(globalThis.Buffer.from(t,"utf-8")):r.decoder.decode(`${r.prefix}${t}`)}const fromString$1=Object.freeze(Object.defineProperty({__proto__:null,fromString},Symbol.toStringTag,{value:"Module"}));async function*validateChunks(t){for await(const e of t){if(e.length===void 0)throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if(typeof e=="string"||e instanceof String)yield fromString(e.toString());else if(Array.isArray(e))yield Uint8Array.from(e);else if(e instanceof Uint8Array)yield e;else throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}}function isIterable(t){return Symbol.iterator in t}function isAsyncIterable(t){return Symbol.asyncIterator in t}function contentAsAsyncIterable(t){try{if(t instanceof Uint8Array)return async function*(){yield t}();if(isIterable(t))return async function*(){yield*t}();if(isAsyncIterable(t))return t}catch{throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*dagBuilder(t,e,r){for await(const n of t)if(n.path&&(n.path.substring(0,2)==="./"&&(r.wrapWithDirectory=!0),n.path=n.path.split("/").filter(i=>i&&i!==".").join("/")),n.content){let i;typeof r.chunker=="function"?i=r.chunker:r.chunker==="rabin"?i=rabinChunker:i=fixedSizeChunker;let o;typeof r.chunkValidator=="function"?o=r.chunkValidator:o=validateChunks;const s={path:n.path,mtime:n.mtime,mode:n.mode,content:i(o(contentAsAsyncIterable(n.content),r),r)};yield()=>fileBuilder(s,e,r)}else if(n.path){const i={path:n.path,mtime:n.mtime,mode:n.mode};yield()=>dirBuilder(i,e,r)}else throw new Error("Import candidate must have content or path or both")}class Dir{constructor(e,r){this.options=r||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,r){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}class DirFlat extends Dir{constructor(e,r){super(e,r),this._children={}}async put(e,r){this.cid=void 0,this.size=void 0,this._children[e]=r}get(e){return Promise.resolve(this._children[e])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async*eachChildSeries(){const e=Object.keys(this._children);for(let r=0;r<e.length;r++){const n=e[r];yield{key:n,child:this._children[n]}}}async*flush(e){const r=Object.keys(this._children),n=[];for(let f=0;f<r.length;f++){let l=this._children[r[f]];if(l instanceof Dir)for await(const m of l.flush(e))l=m,yield l;l.size!=null&&l.cid&&n.push({Name:r[f],Tsize:l.size,Hash:l.cid})}const i=new UnixFS({type:"directory",mtime:this.mtime,mode:this.mode}),o={Data:i.marshal(),Links:n},s=encode$1(prepare(o)),a=await persist(s,e,this.options),c=s.length+o.Links.reduce((f,l)=>f+(l.Tsize==null?0:l.Tsize),0);this.cid=a,this.size=c,yield{cid:a,unixfs:i,path:this.path,size:c}}}const BITS_PER_BYTE=7;var sparseArray=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(e,r){let n=this._internalPositionFor(e,!1);if(r===void 0)n!==-1&&(this._unsetInternalPos(n),this._unsetBit(e),this._changedLength=!0,this._changedData=!0);else{let i=!1;n===-1?(n=this._data.length,this._setBit(e),this._changedData=!0):i=!0,this._setInternalPos(n,e,r,i),this._changedLength=!0}}unset(e){this.set(e,void 0)}get(e){this._sortData();const r=this._internalPositionFor(e,!0);if(r!==-1)return this._data[r][1]}push(e){return this.set(this.length,e),this.length}get length(){if(this._sortData(),this._changedLength){const e=this._data[this._data.length-1];this._length=e?e[0]+1:0,this._changedLength=!1}return this._length}forEach(e){let r=0;for(;r<this.length;)e(this.get(r),r,this),r++}map(e){let r=0,n=new Array(this.length);for(;r<this.length;)n[r]=e(this.get(r),r,this),r++;return n}reduce(e,r){let n=0,i=r;for(;n<this.length;){const o=this.get(n);i=e(i,o,n),n++}return i}find(e){let r=0,n,i;for(;r<this.length&&!n;)i=this.get(r),n=e(i),r++;return n?i:void 0}_internalPositionFor(e,r){const n=this._bytePosFor(e,r);if(n>=this._bitArrays.length)return-1;const i=this._bitArrays[n],o=e-n*BITS_PER_BYTE;if(!((i&1<<o)>0))return-1;const a=this._bitArrays.slice(0,n).reduce(popCountReduce,0),c=~(4294967295<<o+1),f=popCount(i&c);return a+f-1}_bytePosFor(e,r){const n=Math.floor(e/BITS_PER_BYTE),i=n+1;for(;!r&&this._bitArrays.length<i;)this._bitArrays.push(0);return n}_setBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]|=1<<e-r*BITS_PER_BYTE}_unsetBit(e){const r=this._bytePosFor(e,!1);this._bitArrays[r]&=~(1<<e-r*BITS_PER_BYTE)}_setInternalPos(e,r,n,i){const o=this._data,s=[r,n];if(i)this._sortData(),o[e]=s;else{if(o.length)if(o[o.length-1][0]>=r)o.push(s);else if(o[0][0]<=r)o.unshift(s);else{const a=Math.round(o.length/2);this._data=o.slice(0,a).concat(s).concat(o.slice(a))}else this._data.push(s);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(e){this._data.splice(e,1)}_sortData(){this._changedData&&this._data.sort(sortInternal),this._changedData=!1}bitField(){const e=[];let r=8,n=0,i=0,o;const s=this._bitArrays.slice();for(;s.length||n;){n===0&&(o=s.shift(),n=7);const c=Math.min(n,r),f=~(255<<c),l=o&f;i|=l<<8-r,o=o>>>c,n-=c,r-=c,(!r||!n&&!s.length)&&(e.push(i),i=0,r=8)}for(var a=e.length-1;a>0&&e[a]===0;a--)e.pop();return e}compactArray(){return this._sortData(),this._data.map(valueOnly)}};function popCountReduce(t,e){return t+popCount(e)}function popCount(t){let e=t;return e=e-(e>>1&1431655765),e=(e&858993459)+(e>>2&858993459),(e+(e>>4)&252645135)*16843009>>24}function sortInternal(t,e){return t[0]-e[0]}function valueOnly(t){return t[1]}const require$$1$1=getAugmentedNamespace(fromString$1),SparseArray=sparseArray,{fromString:uint8ArrayFromString}=require$$1$1;let Bucket$1=class I{constructor(e,r,n=0){this._options=e,this._popCount=0,this._parent=r,this._posAtParent=n,this._children=new SparseArray,this.key=null}async put(e,r){const n=await this._findNewBucketAndPos(e);await n.bucket._putAt(n,e,r)}async get(e){const r=await this._findChild(e);if(r)return r.value}async del(e){const r=await this._findPlace(e),n=r.bucket._at(r.pos);n&&n.key===e&&r.bucket._delAt(r.pos)}leafCount(){return this._children.compactArray().reduce((r,n)=>n instanceof I?r+n.leafCount():r+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const e=this._children.compactArray();for(const r of e)r instanceof I?yield*r.eachLeafSeries():yield r;return[]}serialize(e,r){const n=[];return r(this._children.reduce((i,o,s)=>(o&&(o instanceof I?i.push(o.serialize(e,r)):i.push(e(o,s))),i),n))}asyncTransform(e,r){return asyncTransformBucket(this,e,r)}toJSON(){return this.serialize(mapNode,reduceNodes)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(e){const r=await this._findPlace(e),n=r.bucket._at(r.pos);if(!(n instanceof I)&&n&&n.key===e)return n}async _findPlace(e){const r=this._options.hash(typeof e=="string"?uint8ArrayFromString(e):e),n=await r.take(this._options.bits),i=this._children.get(n);return i instanceof I?i._findPlace(r):{bucket:this,pos:n,hash:r,existingChild:i}}async _findNewBucketAndPos(e){const r=await this._findPlace(e);if(r.existingChild&&r.existingChild.key!==e){const n=new I(this._options,r.bucket,r.pos);r.bucket._putObjectAt(r.pos,n);const i=await n._findPlace(r.existingChild.hash);return i.bucket._putAt(i,r.existingChild.key,r.existingChild.value),n._findNewBucketAndPos(r.hash)}return r}_putAt(e,r,n){this._putObjectAt(e.pos,{key:r,value:n,hash:e.hash})}_putObjectAt(e,r){this._children.get(e)||this._popCount++,this._children.set(e,r)}_delAt(e){if(e===-1)throw new Error("Invalid position");this._children.get(e)&&this._popCount--,this._children.unset(e),this._level()}_level(){if(this._parent&&this._popCount<=1)if(this._popCount===1){const e=this._children.find(exists);if(e&&!(e instanceof I)){const r=e.hash;r.untake(this._options.bits);const n={pos:this._posAtParent,hash:r,bucket:this._parent};this._parent._putAt(n,e.key,e.value)}}else this._parent._delAt(this._posAtParent)}_at(e){return this._children.get(e)}};function exists(t){return!!t}function mapNode(t,e){return t.key}function reduceNodes(t){return t}async function asyncTransformBucket(t,e,r){const n=[];for(const i of t._children.compactArray())if(i instanceof Bucket$1)await asyncTransformBucket(i,e,r);else{const o=await e(i);n.push({bitField:t._children.bitField(),children:o})}return r(n)}var bucket=Bucket$1,consumableHash={exports:{}};const START_MASKS=[255,254,252,248,240,224,192,128],STOP_MASKS=[1,3,7,15,31,63,127,255];var consumableBuffer=class{constructor(e){this._value=e,this._currentBytePos=e.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(e){let r=e,n=0;for(;r&&this._haveBits();){const i=this._value[this._currentBytePos],o=this._currentBitPos+1,s=Math.min(o,r),a=byteBitsToInt(i,o-s,s);n=(n<<s)+a,r-=s,this._currentBitPos-=s,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return n}untake(e){for(this._currentBitPos+=e;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function byteBitsToInt(t,e,r){const n=maskFor(e,r);return(t&n)>>>e}function maskFor(t,e){return START_MASKS[t]&STOP_MASKS[Math.min(e+t-1,7)]}function concat(t,e){e||(e=t.reduce((i,o)=>i+o.length,0));const r=allocUnsafe(e);let n=0;for(const i of t)r.set(i,n),n+=i.length;return asUint8Array(r)}const concat$1=Object.freeze(Object.defineProperty({__proto__:null,concat},Symbol.toStringTag,{value:"Module"})),require$$1=getAugmentedNamespace(concat$1),ConsumableBuffer=consumableBuffer,{concat:uint8ArrayConcat}=require$$1;function wrapHash$1(t){function e(r){return r instanceof InfiniteHash?r:new InfiniteHash(r,t)}return e}class InfiniteHash{constructor(e,r){if(!(e instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=e,this._hashFn=r,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(e){let r=e;for(;this._availableBits<r;)await this._produceMoreBits();let n=0;for(;r>0;){const i=this._buffers[this._currentBufferIndex],o=Math.min(i.availableBits(),r),s=i.take(o);n=(n<<o)+s,r-=o,this._availableBits-=o,i.availableBits()===0&&this._currentBufferIndex++}return n}untake(e){let r=e;for(;r>0;){const n=this._buffers[this._currentBufferIndex],i=Math.min(n.totalBits()-n.availableBits(),r);n.untake(i),r-=i,this._availableBits+=i,this._currentBufferIndex>0&&n.totalBits()===n.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const e=this._depth?uint8ArrayConcat([this._value,Uint8Array.from([this._depth])]):this._value,r=await this._hashFn(e),n=new ConsumableBuffer(r);this._buffers.push(n),this._availableBits+=n.availableBits()}}consumableHash.exports=wrapHash$1;consumableHash.exports.InfiniteHash=InfiniteHash;var consumableHashExports=consumableHash.exports;const Bucket=bucket,wrapHash=consumableHashExports;function createHAMT(t){if(!t||!t.hashFn)throw new Error("please define an options.hashFn");const e={bits:t.bits||8,hash:wrapHash(t.hashFn)};return new Bucket(e)}var src={createHAMT,Bucket};class DirSharded extends Dir{constructor(e,r){super(e,r),this._bucket=src.createHAMT({hashFn:r.hamtHashFn,bits:r.hamtBucketBits})}async put(e,r){await this._bucket.put(e,r)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:r}of this._bucket.eachLeafSeries())yield{key:e,child:r}}async*flush(e){for await(const r of flush(this._bucket,e,this,this.options))yield{...r,path:this.path}}}async function*flush(t,e,r,n){const i=t._children,o=[];let s=0;for(let h=0;h<i.length;h++){const d=i.get(h);if(!d)continue;const u=h.toString(16).toUpperCase().padStart(2,"0");if(d instanceof src.Bucket){let p;for await(const b of await flush(d,e,null,n))p=b;if(!p)throw new Error("Could not flush sharded directory, no subshard found");o.push({Name:u,Tsize:p.size,Hash:p.cid}),s+=p.size}else if(typeof d.value.flush=="function"){const p=d.value;let b;for await(const D of p.flush(e))b=D,yield b;const A=u+d.key;o.push({Name:A,Tsize:b.size,Hash:b.cid}),s+=b.size}else{const p=d.value;if(!p.cid)continue;const b=u+d.key,A=p.size;o.push({Name:b,Tsize:A,Hash:p.cid}),s+=A}}const a=Uint8Array.from(i.bitField().reverse()),c=new UnixFS({type:"hamt-sharded-directory",data:a,fanout:t.tableSize(),hashType:n.hamtHashCode,mtime:r&&r.mtime,mode:r&&r.mode}),f={Data:c.marshal(),Links:o},l=encode$1(prepare(f)),m=await persist(l,e,n),y=l.length+s;yield{cid:m,unixfs:c,size:y}}async function flatToShard(t,e,r,n){let i=e;e instanceof DirFlat&&e.directChildrenCount()>=r&&(i=await convertToShard(e,n));const o=i.parent;if(o){if(i!==e){if(t&&(t.parent=i),!i.parentKey)throw new Error("No parent key found");await o.put(i.parentKey,i)}return flatToShard(i,o,r,n)}return i}async function convertToShard(t,e){const r=new DirSharded({root:t.root,dir:!0,parent:t.parent,parentKey:t.parentKey,path:t.path,dirty:t.dirty,flat:!1,mtime:t.mtime,mode:t.mode},e);for await(const{key:n,child:i}of t.eachChildSeries())await r.put(n,i);return r}const toPathComponents=(t="")=>(t.trim().match(/([^\\/]|\\\/)+/g)||[]).filter(Boolean);async function addToTree(t,e,r){const n=toPathComponents(t.path||""),i=n.length-1;let o=e,s="";for(let a=0;a<n.length;a++){const c=n[a];s+=`${s?"/":""}${c}`;const f=a===i;if(o.dirty=!0,o.cid=void 0,o.size=void 0,f)await o.put(c,t),e=await flatToShard(null,o,r.shardSplitThreshold,r);else{let l=await o.get(c);(!l||!(l instanceof Dir))&&(l=new DirFlat({root:!1,dir:!0,parent:o,parentKey:c,path:s,dirty:!0,flat:!0,mtime:l&&l.unixfs&&l.unixfs.mtime,mode:l&&l.unixfs&&l.unixfs.mode},r)),await o.put(c,l),o=l}}return e}async function*flushAndYield(t,e){if(!(t instanceof Dir)){t&&t.unixfs&&t.unixfs.isDirectory()&&(yield t);return}yield*t.flush(e)}async function*treeBuilder(t,e,r){let n=new DirFlat({root:!0,dir:!0,path:"",dirty:!0,flat:!0},r);for await(const i of t)i&&(n=await addToTree(i,n,r),(!i.unixfs||!i.unixfs.isDirectory())&&(yield i));if(r.wrapWithDirectory)yield*flushAndYield(n,e);else for await(const i of n.eachChildSeries())i&&(yield*flushAndYield(i.child,e))}async function*importer(t,e,r={}){const n=defaultOptions$1(r);let i;typeof r.dagBuilder=="function"?i=r.dagBuilder:i=dagBuilder;let o;typeof r.treeBuilder=="function"?o=r.treeBuilder:o=treeBuilder;let s;Symbol.asyncIterator in t||Symbol.iterator in t?s=t:s=[t];for await(const a of o(parallelBatch$1(i(s,e,n),n.fileImportConcurrency),e,n))yield{cid:a.cid,path:a.path,unixfs:a.unixfs,size:a.size}}async function*browserReadableStreamToIt$1(t,e={}){const r=t.getReader();try{for(;;){const n=await r.read();if(n.done)return;yield n.value}}finally{e.preventCancel!==!0&&r.cancel(),r.releaseLock()}}var browserReadablestreamToIt=browserReadableStreamToIt$1;const browserStreamToIt=getDefaultExportFromCjs(browserReadablestreamToIt),browserReadableStreamToIt=browserReadablestreamToIt;function blobToIt(t){return typeof t.stream=="function"?browserReadableStreamToIt(t.stream()):browserReadableStreamToIt(new Response(t).body)}var blobToIt_1=blobToIt;const blobToIt$1=getDefaultExportFromCjs(blobToIt_1);function peekableIterator(t){const[e,r]=t[Symbol.asyncIterator]?[t[Symbol.asyncIterator](),Symbol.asyncIterator]:[t[Symbol.iterator](),Symbol.iterator],n=[];return{peek:()=>e.next(),push:i=>{n.push(i)},next:()=>n.length?{done:!1,value:n.shift()}:e.next(),[r](){return this}}}var itPeekable=peekableIterator;const itPeekable$1=getDefaultExportFromCjs(itPeekable),map=async function*(t,e){for await(const r of t)yield e(r)};var itMap=map;const map$1=getDefaultExportFromCjs(itMap);function isBytes$1(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}function isBlob$2(t){return t.constructor&&(t.constructor.name==="Blob"||t.constructor.name==="File")&&typeof t.stream=="function"}function isFileObject(t){return typeof t=="object"&&(t.path||t.content)}const isReadableStream=t=>t&&typeof t.getReader=="function";async function*toAsyncIterable(t){yield t}async function normaliseContent(t){if(isBytes$1(t))return toAsyncIterable(toBytes(t));if(typeof t=="string"||t instanceof String)return toAsyncIterable(toBytes(t.toString()));if(isBlob$2(t))return blobToIt$1(t);if(isReadableStream(t)&&(t=browserStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const e=itPeekable$1(t),{value:r,done:n}=await e.peek();if(n)return toAsyncIterable(new Uint8Array(0));if(e.push(r),Number.isInteger(r))return toAsyncIterable(Uint8Array.from(await all$1(e)));if(isBytes$1(r)||typeof r=="string"||r instanceof String)return map$1(e,toBytes)}throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT")}function toBytes(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Array.isArray(t)?Uint8Array.from(t):fromString(t.toString())}async function*normaliseCandidateSingle(t,e){if(t==null)throw errCode$1(new Error(`Unexpected input: ${t}`),"ERR_UNEXPECTED_INPUT");if(typeof t=="string"||t instanceof String){yield toFileObject$1(t.toString(),e);return}if(isBytes$1(t)||isBlob$2(t)){yield toFileObject$1(t,e);return}if(isReadableStream(t)&&(t=browserStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const r=itPeekable$1(t),{value:n,done:i}=await r.peek();if(i){yield{content:[]};return}if(r.push(n),Number.isInteger(n)||isBytes$1(n)||typeof n=="string"||n instanceof String){yield toFileObject$1(r,e);return}throw errCode$1(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(isFileObject(t)){yield toFileObject$1(t,e);return}throw errCode$1(new Error('Unexpected input: cannot convert "'+typeof t+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT")}async function toFileObject$1(t,e){const{path:r,mode:n,mtime:i,content:o}=t,s={path:r||"",mode:parseMode(n),mtime:parseMtime(i)};return o?s.content=await e(o):r||(s.content=await e(t)),s}function normaliseInput$1(t){return normaliseCandidateSingle(t,normaliseContent)}async function*normaliseCandidateMultiple(t,e){if(typeof t=="string"||t instanceof String||isBytes$1(t)||isBlob$2(t)||t._readableState)throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(isReadableStream(t)&&(t=browserStreamToIt(t)),Symbol.iterator in t||Symbol.asyncIterator in t){const r=itPeekable$1(t),{value:n,done:i}=await r.peek();if(i){yield*[];return}if(r.push(n),Number.isInteger(n))throw errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(n._readableState){yield*map$1(r,o=>toFileObject({content:o},e));return}if(isBytes$1(n)){yield toFileObject({content:r},e);return}if(isFileObject(n)||n[Symbol.iterator]||n[Symbol.asyncIterator]||isReadableStream(n)||isBlob$2(n)){yield*map$1(r,o=>toFileObject(o,e));return}}throw isFileObject(t)?errCode$1(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT"):errCode$1(new Error("Unexpected input: "+typeof t),"ERR_UNEXPECTED_INPUT")}async function toFileObject(t,e){const{path:r,mode:n,mtime:i,content:o}=t,s={path:r||"",mode:parseMode(n),mtime:parseMtime(i)};return o?s.content=await e(o):r||(s.content=await e(t)),s}function normaliseInput(t){return normaliseCandidateMultiple(t,normaliseContent)}function isBytes(t){return ArrayBuffer.isView(t)||t instanceof ArrayBuffer}function isBlob$1(t){return!!t.constructor&&(t.constructor.name==="Blob"||t.constructor.name==="File")&&typeof t.stream=="function"}function isSingle(t){return typeof t=="string"||t instanceof String||isBytes(t)||isBlob$1(t)||"_readableState"in t}function getNormaliser(t){return isSingle(t)?normaliseInput$1(t):normaliseInput(t)}const drain=async t=>{for await(const e of t);};var itDrain=drain;const drain$1=getDefaultExportFromCjs(itDrain),filter=async function*(t,e){for await(const r of t)await e(r)&&(yield r)};var itFilter=filter;const filter$1=getDefaultExportFromCjs(itFilter),take=async function*(t,e){let r=0;if(!(e<1)){for await(const n of t)if(yield n,r++,r===e)return}};var itTake=take;const take$1=getDefaultExportFromCjs(itTake),sortAll=(t,e)=>async function*(){yield*(await all$1(t)).sort(e)}();class BaseBlockstore{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,r,n){return Promise.reject(new Error(".put is not implemented"))}get(e,r){return Promise.reject(new Error(".get is not implemented"))}has(e,r){return Promise.reject(new Error(".has is not implemented"))}delete(e,r){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,r={}){for await(const{key:n,value:i}of e)await this.put(n,i,r),yield{key:n,value:i}}async*getMany(e,r={}){for await(const n of e)yield this.get(n,r)}async*deleteMany(e,r={}){for await(const n of e)await this.delete(n,r),yield n}batch(){let e=[],r=[];return{put(n,i){e.push({key:n,value:i})},delete(n){r.push(n)},commit:async n=>{await drain$1(this.putMany(e,n)),e=[],await drain$1(this.deleteMany(r,n)),r=[]}}}async*_all(e,r){throw new Error("._all is not implemented")}async*_allKeys(e,r){throw new Error("._allKeys is not implemented")}query(e,r){let n=this._all(e,r);if(e.prefix!=null&&(n=filter$1(n,i=>i.key.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((i,o)=>filter$1(i,o),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,o)=>sortAll(i,o),n)),e.offset!=null){let i=0;n=filter$1(n,()=>i++>=(e.offset||0))}return e.limit!=null&&(n=take$1(n,e.limit)),n}queryKeys(e,r){let n=this._allKeys(e,r);if(e.prefix!=null&&(n=filter$1(n,i=>i.toString().startsWith(e.prefix||""))),Array.isArray(e.filters)&&(n=e.filters.reduce((i,o)=>filter$1(i,o),n)),Array.isArray(e.orders)&&(n=e.orders.reduce((i,o)=>sortAll(i,o),n)),e.offset!=null){let i=0;n=filter$1(n,()=>i++>=e.offset)}return e.limit!=null&&(n=take$1(n,e.limit)),n}}class MemoryBlockStore extends BaseBlockstore{constructor(){super(),this.store=new Map}async*blocks(){for(const[e,r]of this.store.entries())yield{cid:CID.parse(e),bytes:r}}put(e,r){return this.store.set(e.toString(),r),Promise.resolve()}get(e){const r=this.store.get(e.toString());if(!r)throw new Error(`block with cid ${e.toString()} no found`);return Promise.resolve(r)}has(e){return Promise.resolve(this.store.has(e.toString()))}close(){return this.store.clear(),Promise.resolve()}}const unixfsImporterOptionsDefault={cidVersion:1,chunker:"fixed",maxChunkSize:262144,hasher:sha256,rawLeaves:!0,wrapWithDirectory:!0,maxChildrenPerNode:174};async function pack({input:t,blockstore:e,hasher:r,maxChunkSize:n,maxChildrenPerNode:i,wrapWithDirectory:o,rawLeaves:s}){if(!t||Array.isArray(t)&&!t.length)throw new Error("missing input file(s)");const a=e||new MemoryBlockStore,c=await last$1(pipe$1(getNormaliser(t),p=>importer(p,a,{...unixfsImporterOptionsDefault,hasher:r||unixfsImporterOptionsDefault.hasher,maxChunkSize:n||unixfsImporterOptionsDefault.maxChunkSize,maxChildrenPerNode:i||unixfsImporterOptionsDefault.maxChildrenPerNode,wrapWithDirectory:o===!1?!1:unixfsImporterOptionsDefault.wrapWithDirectory,rawLeaves:s??unixfsImporterOptionsDefault.rawLeaves})));if(!c||!c.cid)throw new Error("given input could not be parsed correctly");const f=c.cid,{writer:l,out:m}=await CarWriter.create([f]),y=m[Symbol.asyncIterator]();let h;const d=async()=>{for await(const p of a.blocks())await l.put(p);await l.close(),e||await a.close()},u={[Symbol.asyncIterator](){if(h!=null)throw new Error("Multiple iterator not supported");return h=d(),{async next(){const p=await y.next();return p.done&&await h,p}}}};return{root:f,out:u}}var throttledQueue$1={exports:{}};(function(t,e){Object.defineProperty(e,"__esModule",{value:!0});function r(n,i,o){o===void 0&&(o=!1),o&&(i=i/n,n=1);var s=[],a=0,c=0,f,l=function(){var m=a+i,y=Date.now();if(y<m){f!==void 0&&clearTimeout(f),f=setTimeout(l,m-y);return}a=y,c=0;for(var h=0,d=s.splice(0,n);h<d.length;h++){var u=d[h];c++,u()}s.length?f=setTimeout(l,i):f=void 0};return function(m){return new Promise(function(y,h){var d=function(){return Promise.resolve().then(m).then(y).catch(h)},u=Date.now();f===void 0&&u-a>i&&(a=u,c=0),c++<n?d():(s.push(d),f===void 0&&(f=setTimeout(l,a+i-u)))})}}t.exports=r,e.default=r})(throttledQueue$1,throttledQueue$1.exports);var throttledQueueExports=throttledQueue$1.exports;const throttledQueue=getDefaultExportFromCjs(throttledQueueExports),fetch$1=globalThis.fetch,Blob$1=globalThis.Blob,Blockstore=MemoryBlockStore,GATEWAY=new URL("https://nftstorage.link/"),toGatewayURL=(t,e={})=>{const r=e.gateway||GATEWAY;return t=new URL(String(t)),t.protocol==="ipfs:"?new URL(`/ipfs/${t.href.slice(7)}`,r):t};class BlockstoreCarReader{constructor(e,r,n){this._version=e,this._roots=r,this._blockstore=n}get version(){return this._version}get blockstore(){return this._blockstore}async getRoots(){return this._roots}has(e){return this._blockstore.has(e)}async get(e){const r=await this._blockstore.get(e);return{cid:e,bytes:r}}blocks(){return this._blockstore.blocks()}async*cids(){for await(const e of this.blocks())yield e.cid}}class Token{constructor(e,r,n){this.ipnft=e,this.url=r,this.data=n,Object.defineProperties(this,{ipnft:{enumerable:!0,writable:!1},url:{enumerable:!0,writable:!1},data:{enumerable:!1,writable:!1}})}embed(){return Token.embed(this)}static embed({data:e}){return embed(e,{gateway:GATEWAY})}static async encode(e){var f,l;const r=new Blockstore,[n,i]=mapTokenInputBlobs(e),o=JSON.parse(JSON.stringify(i)),s=JSON.parse(JSON.stringify(i));for(const[m,y]of n.entries()){const h=y.name||"blob";let d;parseInt((l=(f=globalThis.process)==null?void 0:f.versions)==null?void 0:l.node)>18?d=new Uint8Array(await y.arrayBuffer()):d=y.stream();const{root:u}=await pack({input:[{path:h,content:d}],blockstore:r,wrapWithDirectory:!0}),p=new URL(`ipfs://${u}/${h}`),b=m.split(".");setIn(o,b,p),setIn(s,b,u)}const{root:a}=await pack({input:[{path:"metadata.json",content:JSON.stringify(o)}],blockstore:r,wrapWithDirectory:!1}),c=await encode$4({value:{...s,"metadata.json":a,type:"nft"},codec:dagCbor,hasher:sha256});return await r.put(c.cid,c.bytes),{cid:c.cid,token:new Token(c.cid.toString(),`ipfs://${c.cid}/metadata.json`,o),car:new BlockstoreCarReader(1,[c.cid],r)}}}const embed=(t,e)=>mapWith(t,isURL,embedURL,e),isURL=t=>t instanceof URL,embedURL=(t,e)=>[t,toGatewayURL(e,t)],isObject=t=>typeof t=="object"&&t!=null,encodeBlob=(t,e,r)=>(t.set(r.join("."),e),[t,void 0]),isBlob=t=>t instanceof Blob$1,mapTokenInputBlobs=t=>mapValueWith(t,isBlob,encodeBlob,new Map,[]),mapWith=(t,e,r,n)=>{const[,i]=mapValueWith(t,e,r,n,[]);return i},mapValueWith=(t,e,r,n,i)=>e(t,n,i)?r(n,t,i):Array.isArray(t)?mapArrayWith(t,e,r,n,i):isObject(t)?mapObjectWith(t,e,r,n,i):[n,t],mapObjectWith=(t,e,r,n,i)=>{let o=n;const s={};for(const[a,c]of Object.entries(t)){const[f,l]=mapValueWith(c,e,r,o,[...i,a]);s[a]=l,o=f}return[o,s]},mapArrayWith=(t,e,r,n,i)=>{const o=[];let s=n;for(const[a,c]of t.entries()){const[f,l]=mapValueWith(c,e,r,s,[...i,a]);o[a]=l,s=f}return[s,o]},setIn=(t,e,r)=>{const n=e.length-1;let i=t;for(let[o,s]of e.entries())o===n?i[s]=r:i=i[s]},MAX_STORE_RETRIES=5,MAX_CONCURRENT_UPLOADS=3,MAX_CHUNK_SIZE=1024*1024*50,RATE_LIMIT_REQUESTS=30,RATE_LIMIT_PERIOD=10*1e3;function createRateLimiter(){const t=throttledQueue(RATE_LIMIT_REQUESTS,RATE_LIMIT_PERIOD);return()=>t(()=>{})}const globalRateLimiter=createRateLimiter();class NFTStorage{constructor({token:e,did:r,endpoint:n=new URL("https://api.nft.storage"),rateLimiter:i}){this.token=e,this.endpoint=n,this.rateLimiter=i||createRateLimiter(),this.did=r}static auth({token:e,did:r}){if(!e)throw new Error("missing token");return{Authorization:`Bearer ${e}`,"X-Client":"nft.storage/js",...r?{"x-agent-did":r}:{}}}static async storeBlob(e,r,n){const i=new Blockstore;let o;try{const{cid:s,car:a}=await NFTStorage.encodeBlob(r,{blockstore:i});await NFTStorage.storeCar(e,a,n),o=s.toString()}finally{await i.close()}return o}static async storeCar({endpoint:e,rateLimiter:r=globalRateLimiter,...n},i,{onStoredChunk:o,maxRetries:s,maxChunkSize:a,decoders:c,signal:f}={}){const l=new URL("upload/",e),m={...NFTStorage.auth(n),"Content-Type":"application/car"},y=a||MAX_CHUNK_SIZE,h=i instanceof Blob$1?await TreewalkCarSplitter.fromBlob(i,y,{decoders:c}):new TreewalkCarSplitter(i,y,{decoders:c}),d=transform(MAX_CONCURRENT_UPLOADS,async function(p){var g,w;const b=[];for await(const _ of p)b.push(_);const A=new Blob$1(b,{type:"application/car"});let D=A;parseInt((w=(g=globalThis.process)==null?void 0:g.versions)==null?void 0:w.node)>18&&(D=await D.arrayBuffer());const T=await pRetry$1(async()=>{await r();let _;try{_=await fetch$1(l.toString(),{method:"POST",headers:m,body:D,signal:f})}catch(E){throw f&&f.aborted?new AbortError_1(E):E}if(_.status===429)throw new Error("rate limited");const $=await _.json();if(!$.ok)throw _.status===401?new AbortError_1($.error.message):new Error($.error.message);return $.value.cid},{retries:s??MAX_STORE_RETRIES});return o&&o(A.size),T});let u;for await(const p of d(h.cars()))u=p;return u}static async storeDirectory(e,r,n){const i=new Blockstore;let o;try{const{cid:s,car:a}=await NFTStorage.encodeDirectory(r,{blockstore:i});await NFTStorage.storeCar(e,a,n),o=s.toString()}finally{await i.close()}return o}static async store(e,r,n){const{token:i,car:o}=await NFTStorage.encodeNFT(r);return await NFTStorage.storeCar(e,o,n),i}static async status({endpoint:e,rateLimiter:r=globalRateLimiter,...n},i,o){const s=new URL(`${i}/`,e);await r();const a=await fetch$1(s.toString(),{method:"GET",headers:NFTStorage.auth(n),signal:o&&o.signal});if(a.status===429)throw new Error("rate limited");const c=await a.json();if(c.ok)return{cid:c.value.cid,deals:decodeDeals(c.value.deals),size:c.value.size,pin:decodePin(c.value.pin),created:new Date(c.value.created)};throw new Error(c.error.message)}static async check({endpoint:e,rateLimiter:r=globalRateLimiter},n,i){const o=new URL(`check/${n}/`,e);await r();const s=await fetch$1(o.toString(),{signal:i&&i.signal});if(s.status===429)throw new Error("rate limited");const a=await s.json();if(a.ok)return{cid:a.value.cid,deals:decodeDeals(a.value.deals),pin:a.value.pin};throw new Error(a.error.message)}static async delete({endpoint:e,rateLimiter:r=globalRateLimiter,...n},i,o){const s=new URL(`${i}/`,e);await r();const a=await fetch$1(s.toString(),{method:"DELETE",headers:NFTStorage.auth(n),signal:o&&o.signal});if(a.status===429)throw new Error("rate limited");const c=await a.json();if(!c.ok)throw new Error(c.error.message)}static async encodeNFT(e){return validateERC1155(e),Token.encode(e)}static async encodeBlob(e,{blockstore:r}={}){if(e.size===0)throw new Error("Content size is 0, make sure to provide some content");return packCar([toImportCandidate("blob",e)],{blockstore:r,wrapWithDirectory:!1})}static async encodeDirectory(e,{blockstore:r}={}){let n=0;const i=pipe$1(e,async function*(s){for await(const a of s)yield toImportCandidate(a.name,a),n+=a.size}),o=await packCar(i,{blockstore:r,wrapWithDirectory:!0});if(n===0)throw new Error("Total size of files should exceed 0, make sure to provide some content");return o}storeBlob(e,r){return NFTStorage.storeBlob(this,e,r)}storeCar(e,r){return NFTStorage.storeCar(this,e,r)}storeDirectory(e,r){return NFTStorage.storeDirectory(this,e,r)}status(e,r){return NFTStorage.status(this,e,r)}delete(e,r){return NFTStorage.delete(this,e,r)}check(e,r){return NFTStorage.check(this,e,r)}store(e,r){return NFTStorage.store(this,e,r)}}const validateERC1155=({name:t,description:e,image:r,decimals:n})=>{if(typeof t!="string")throw new TypeError("string property `name` identifying the asset is required");if(typeof e!="string")throw new TypeError("string property `description` describing asset is required");if(r instanceof Blob$1)r.type.startsWith("image/")||console.warn(`According to ERC721 Metadata JSON Schema 'image' must have 'image/*' mime type.

For better interoperability we would highly recommend storing content with different mime type under 'properties' namespace e.g. \`properties: { video: file }\` and using 'image' field for storing a preview image for it instead.

For more context please see ERC-721 specification https://eips.ethereum.org/EIPS/eip-721`);else throw new TypeError("property `image` must be a Blob or File object");if(typeof n<"u"&&typeof n!="number")throw new TypeError("property `decimals` must be an integer value")},packCar=async(t,{blockstore:e,wrapWithDirectory:r}={})=>{e=e||new Blockstore;const{root:n}=await pack({input:t,blockstore:e,wrapWithDirectory:r}),i=new BlockstoreCarReader(1,[n],e);return{cid:n,car:i}},decodeDeals=t=>t.map(e=>{const{dealActivation:r,dealExpiration:n,lastChanged:i}={dealExpiration:null,dealActivation:null,...e};return{...e,lastChanged:new Date(i),...r&&{dealActivation:new Date(r)},...n&&{dealExpiration:new Date(n)}}}),decodePin=t=>({...t,created:new Date(t.created)});function toImportCandidate(t,e){let r;return{path:t,get content(){return r=r||e.stream(),r}}}const client=new NFTStorage({token:PUBLIC_NFT_STORAGE_API_KEY}),storeMetaData=async t=>{try{const e=JSON.stringify(t),r=new Blob([e],{type:"application/json"});return[await client.storeBlob(r),null]}catch(e){return console.error(e),[null,e]}},createReview=async t=>{try{let e="";jwtToken.subscribe(o=>e=o);const r={method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${e}`},body:JSON.stringify(t)};return await(await fetch(`${PUBLIC_GATEWAY_URL}/delegateReviewCreation`,r)).json()}catch(e){return console.error(e),[null,e]}};async function storeMetaDataPin(t){try{const e=JSON.stringify(t),r=new Blob([e],{type:"application/json"}),i=await(await fetch("https://api.pinata.cloud/pinning/pinJSONToIPFS",{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${PUBLIC_PINATA_JWT}`},body:r})).json();return new FormData().append("metadata",JSON.stringify(i)),console.log(i.IpfsHash),[i.IpfsHash,null]}catch(e){return console.error(e),[null,e]}}function create_fragment(t){let e,r;return{c(){e=svg_element("svg"),r=svg_element("path"),this.h()},l(n){e=claim_svg_element(n,"svg",{xmlns:!0,width:!0,height:!0,viewBox:!0,fill:!0});var i=children(e);r=claim_svg_element(i,"path",{d:!0,fill:!0}),children(r).forEach(detach),i.forEach(detach),this.h()},h(){attr(r,"d","M3.80827 5.51953L0.510449 1.56215C0.0762306 1.04109 0.446755 0.25 1.12503 0.25L6.87562 0.25C7.5539 0.25 7.92442 1.04109 7.4902 1.56215L4.19238 5.51953C4.09243 5.63947 3.90822 5.63947 3.80827 5.51953Z"),attr(r,"fill",t[0]),attr(e,"xmlns","http://www.w3.org/2000/svg"),attr(e,"width","8"),attr(e,"height","6"),attr(e,"viewBox","0 0 8 6"),attr(e,"fill","none")},m(n,i){insert_hydration(n,e,i),append_hydration(e,r)},p(n,[i]){i&1&&attr(r,"fill",n[0])},i:noop$2,o:noop$2,d(n){n&&detach(e)}}}function instance(t,e,r){let n,i;return darktheme.subscribe(o=>r(1,i=o)),t.$$.update=()=>{t.$$.dirty&2&&r(0,n=i?"#11D9C5":"#263238")},[n,i]}class Arrow extends SvelteComponent{constructor(e){super(),init(this,e,instance,create_fragment,safe_not_equal,{})}}export{Arrow as A,storeMetaData as a,createReview as c,storeMetaDataPin as s};
